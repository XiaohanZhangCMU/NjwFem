// Classical Lagrange basis functions are scalar valued and all
// derivatives are defined.  The boundary is a Lagrange basis
// function of one dimension less.

template<const int Ndim>
struct LagrangeBasisFunction : public basisFunction<Ndim>
{
  LagrangeBasisFunction(basisFunction<Ndim> &bf, 
	       LagrangeBasisFunction<Ndim-1> *bdy,
	       void (*bb)(svector<Ndim>, double *phi, svector<Ndim> *dphi))
    : basisFunction<Ndim>(bf), boundary(bdy), basis(bb)
  {return;}

  LagrangeBasisFunction<Ndim-1> *boundary;
  void (*basis)(svector<Ndim>, double *phi, svector<Ndim> *dphi);
};

template<const int Ndim>
struct LagrangeBasisFunctionBar : public basisFunction<Ndim>
{
  LagrangeBasisFunctionBar(basisFunction<Ndim> &bf, 
   LagrangeBasisFunction<Ndim-1> *bdy,
   void (*bb)(svector<Ndim>, double *phi, svector<Ndim> *dphi, double *phiBar))
    : basisFunction<Ndim>(bf), boundary(bdy), basis(bb)
  {return;}

  LagrangeBasisFunction<Ndim-1> *boundary;
  void (*basis)(svector<Ndim>, double *phi, 
		svector<Ndim> *dphi, double *phiBar);
};

// **************** classical Lagrange finite elements ***************
// **************** classical Lagrange finite elements ***************
// **************** classical Lagrange finite elements ***************

void line1(svector<1> eta, double psi[1], svector<1> dpsi[1]);
void line2(svector<1> eta, double psi[2], svector<1> dpsi[2]);
void line3(svector<1> eta, double psi[3], svector<1> dpsi[3]);
void line4(svector<1>  xi, double psi[4], svector<1> dpsi[4]);
void line5(svector<1>  xi, double psi[5], svector<1> dpsi[5]);
void line6(svector<1>  xi, double psi[6], svector<1> dpsi[6]);

// projections of lineX() basis functions onto polynomials
// of one degree less. The last argument should be NULL

void line2bar(svector<1> peta, double psi[2], 
	      svector<1> dpsi[2], double psiBar[2]);
void line3bar(svector<1> peta, double psi[3], 
	      svector<1> dpsi[3], double psiBar[3]);

void tri3(svector<2> xi, double psi[3], svector<2> dpsi[3]);
void tri6(svector<2> xi, double psi[6], svector<2> dpsi[6]);
void tri10(svector<2> pt, double psi[10], svector<2> dpsi[10]);

void tet4( const svector<3> xi, double phi[4] , svector<3> dphi[4]);
void tet10(const svector<3> xi, double phi[10], svector<3> dphi[10]);
void tet20(const svector<3> pt, double psi[20], svector<3> dpsi[20]);  

void quad4(svector<2> xi, double psi[4], svector<2> dsi[4]);
void quad8(svector<2> xi, double phi[8], svector<2> dphi[8]);
void quad9(svector<2> xi, double phi[9], svector<2> dphi[9]);
void quad12(svector<2> xi, double phi[12], svector<2> dphi[12]);
void quad16(svector<2> xi, double phi[16], svector<2> dphi[16]);
void quad17(svector<2> xi, double phi[17], svector<2> dphi[17]);
void quad24(svector<2> xi, double phi[24], svector<2> dphi[24]);

void cube8(svector<3>, double psi[8], svector<3> dpsi[8]);
void cube20(svector<3>, double psi[20], svector<3> dpsi[20]);
void cube27(svector<3>, double psi[27], svector<3> dpsi[27]);

void tri3Bubble(svector<2> xi, double psi[4], svector<2> dpsi[4]);
void tet4Bubble(svector<3> xi, double phi[5] , svector<3> dphi[5]);
void quad4Bubble(svector<2> xi, double psi[5], svector<2> dsi[5]);
void cube8Bubble(svector<3>, double psi[9], svector<3> dpsi[9]);

void tri3BubbleInterp(svector<2> xi, double sn[4], svector<2> dsn[4]);

void sortDof(int n, int *nn, int *dd);
void line4Permutation(const int *nodes, int *dof);
void line5Permutation(const int *nodes, int *dof);
void line6Permutation(const int *nodes, int *dof);
void tri10Permutation(const int *nodes, int *dof);
void tet20Permutation(const int *nodes, int *dof);
void quad12Permutation(const int *nodes, int *dof);
void quad16Permutation(const int *nodes, int *dof);
void quad17Permutation(const int *nodes, int *dof);
void quad24Permutation(const int *nodes, int *dof);

// ********** Vertex terminates the boundary reccursion *********
// ********** Vertex terminates the boundary reccursion *********
// ********** Vertex terminates the boundary reccursion *********

basisFunction<0> Vertex1BF =    // ends the boundary reccursion
  {1,
   {1},
   NULL,
   NULL,
   0,
   NULL,
   identityPermutation,
  };

LagrangeBasisFunction<0> Vertex1class(Vertex1BF, NULL, NULL),
  *Vertex1 = &Vertex1class;

// ***************** 1d Functions on Interval **********************
// ***************** 1d Functions on Interval **********************
// ***************** 1d Functions on Interval **********************

svector<1> Line3Pts[] = {svector<1>(-1.0), svector<1>(1.0), svector<1>(0.0)};
 
basisFunction<1> Line2BF =  // one-d linear element basis fns
  {2,
   {1,0},
   Vertex1,
   &Interval,
   2,
   Line3Pts,
   identityPermutation
  };

LagrangeBasisFunction<1> Line2class(Line2BF, Vertex1, line2),
  *Line2 = &Line2class;

basisFunction<1> Line2barBF =   // projections of Line2 onto P_0
  {2,
   {1,0},
   Vertex1,
   &Interval,
   2,
   Line3Pts,
   identityPermutation,
  };

LagrangeBasisFunctionBar<1> Line2barClass(Line2barBF, Vertex1, line2bar),
  *Line2bar = &Line2barClass;

basisFunction<1> Line3BF =    // one-d quadratic basis fns
  {3,
   {1,1},
   Vertex1,
   &Interval,
   3,
   Line3Pts,
   identityPermutation
  };

LagrangeBasisFunction<1> Line3class(Line3BF, Vertex1, line3),
  *Line3 = &Line3class;

basisFunction<1> Line3barBF =   // Project one-d quadratics onto linears
  {3,
   {1,1},
   Vertex1,
   &Interval,
   3,
   Line3Pts,
   identityPermutation
  };

LagrangeBasisFunctionBar<1> Line3barClass(Line3barBF, Vertex1, line3bar),
  *Line3bar = &Line3barClass;

// svector<1> Line4Pts[] = {svector<1>(-1.0), svector<1>(1.0), 
// 			 svector<1>(-1.0/3.0), svector<1>(1.0/3.0)};

svector<1> Line4Pts[] = {svector<1>(-1.0), svector<1>(1.0), 
	       svector<1>(-1.0/sqrt(5.0)), svector<1>(1.0/sqrt(5.0))};

basisFunction<1> Line4BF =    // one-d cubic basis fns
  {4,
   {1,2},
   Vertex1,
   &Interval,
   4,
   Line4Pts,
   line4Permutation
  };

LagrangeBasisFunction<1> Line4class(Line4BF, Vertex1, line4),
  *Line4 = &Line4class;

svector<1> Line5Pts[] = {svector<1>(-1.0), svector<1>(1.0), 
   svector<1>(-sqrt(3.0/7.0)), svector<1>(0.0), svector<1>(sqrt(3.0/7.0))};

basisFunction<1> Line5BF =    // one-d cubic basis fns
  {5,
   {1,3},
   Vertex1,
   &Interval,
   5,
   Line5Pts,
   line5Permutation
  };

LagrangeBasisFunction<1> Line5class(Line5BF, Vertex1, line5),
  *Line5 = &Line5class;

svector<1> Line6Pts[] = 
  {svector<1>(-1.0), svector<1>(1.0), 
   svector<1>(-sqrt((3+2*sqrt(6.0/5))/7.0)),
   svector<1>(-sqrt((3-2*sqrt(6.0/5))/7.0)), 
   svector<1>( sqrt((3-2*sqrt(6.0/5))/7.0)),
   svector<1>( sqrt((3+2*sqrt(6.0/5))/7.0))};

basisFunction<1> Line6BF =    // one-d cubic basis fns
  {6,
   {1,4},
   Vertex1,
   &Interval,
   6,
   Line6Pts,
   line6Permutation
  };

LagrangeBasisFunction<1> Line6class(Line6BF, Vertex1, line6),
  *Line6 = &Line6class;

// ***************** 2d Functions on Triangle **********************
// ***************** 2d Functions on Triangle **********************
// ***************** 2d Functions on Triangle **********************

svector<2> Triangle6Pts[] = 
  {svector<2>(0.0, 0.0), svector<2>(1.0, 0.0), svector<2>(0.0, 1.0), 
   svector<2>(0.5, 0.0), svector<2>(0.5, 0.5), svector<2>(0.0, 0.5)};

basisFunction<2> Triangle3BF =    // two-d linear basis fns
  {3,
   {1,0,0},
   Line2,
   &Triangle,
   3,
   Triangle6Pts,
   identityPermutation
  };

LagrangeBasisFunction<2> Triangle3class(Triangle3BF, Line2, tri3),
 *Triangle3 = &Triangle3class;

svector<2> Triangle3BubblePts[] = 
  {svector<2>(0.0, 0.0), svector<2>(1.0, 0.0), svector<2>(0.0, 1.0), 
   svector<2>(1.0/3.0, 1.0/3.0)};

basisFunction<2> Triangle3BubbleBF =    // two-d linear basis fns
  {4,
   {1,0,1},
   Line2,
   &Triangle,
   3,                        // not clear how to initialize bubble
   Triangle3BubblePts,
   identityPermutation,
  };

LagrangeBasisFunction<2> 
  Triangle3BubbleClass(Triangle3BubbleBF, Line2, tri3Bubble),
  *Triangle3Bubble = &Triangle3BubbleClass;

// Alternative, interpolate at all 4 points and use tri3BubbleInterp()

LagrangeBasisFunction<2> 
  Triangle3BubbleInterpClass(Triangle3BubbleBF, Line2, tri3BubbleInterp),
  *Triangle3BubbleInterp = &Triangle3BubbleInterpClass;

basisFunction<2> Triangle6BF =    // two-d quadratic basis fns
  {6,
   {1,1,0},
   Line3,
   &Triangle,
   6,
   Triangle6Pts,
   identityPermutation
  };

LagrangeBasisFunction<2> Triangle6class(Triangle6BF, Line3, tri6),
  *Triangle6 = &Triangle6class;

svector<2> Triangle10Pts[10] = 
  {svector<2>(0.0, 0.0), svector<2>(1.0, 0.0), svector<2>(0.0, 1.0), 
   svector<2>(0.5*(1-1.0/sqrt(5.0)), 0.0), 
   svector<2>(0.5*(1+1.0/sqrt(5.0)), 0.0),
   svector<2>(0.5*(1+1.0/sqrt(5.0)), 0.5*(1-1.0/sqrt(5.0))), 
   svector<2>(0.5*(1-1.0/sqrt(5.0)), 0.5*(1+1.0/sqrt(5.0))),
   svector<2>(0.0, 0.5*(1+1.0/sqrt(5.0))), 
   svector<2>(0.0, 0.5*(1-1.0/sqrt(5.0))),
   svector<2>(1.0/3.0, 1.0/3.0)};

basisFunction<2> Triangle10BF =    // two-d quadratic basis fns
  {10,
   {1,2,1},
   Line4,
   &Triangle,
   10,
   Triangle10Pts,
   tri10Permutation
  };

LagrangeBasisFunction<2> Triangle10class(Triangle10BF, Line4, tri10),
  *Triangle10 = &Triangle10class;

// ***************** 2d Functions on Square **********************
// ***************** 2d Functions on Square **********************
// ***************** 2d Functions on Square **********************

svector<2> Square9Pts[] = {svector<2>(-1.0,-1.0), svector<2>( 1.0,-1.0), 
			 svector<2>( 1.0, 1.0), svector<2>(-1.0, 1.0),
			 svector<2>( 0.0,-1.0), svector<2>( 1.0, 0.0),
			 svector<2>( 0.0, 1.0), svector<2>(-1.0, 0.0),
			 svector<2>( 0.0, 0.0)};

basisFunction<2> Square4BF =    // two-d bilinear basis fns
  {4,
   {1,0,0},
   Line2,
   &Square,
   4,
   Square9Pts,
   identityPermutation
  };

LagrangeBasisFunction<2> Square4class(Square4BF, Line2, quad4),
  *Square4 = &Square4class;

svector<2> Square4BubblePts[] = 
  {svector<2>(-1.0,-1.0), svector<2>( 1.0,-1.0), 
   svector<2>( 1.0, 1.0), svector<2>(-1.0, 1.0),
   svector<2>( 0.0, 0.0)};

basisFunction<2> Square4BubbleBF =    // two-d bilinear basis fns
  {5,
   {1,0,1},
   Line2,
   &Square,
   4,                           // not clear how to initialize bubble
   Square4BubblePts,
   identityPermutation
  };

LagrangeBasisFunction<2> 
  Square4BubbleClass(Square4BubbleBF, Line2, quad4Bubble),
  *Square4Bubble = &Square4BubbleClass;

basisFunction<2> Square8BF =    // serindipity two-d biquadratic basis fns
  {8,
   {1,1,0},
   Line3,
   &Square,
   8,
   Square9Pts,
   identityPermutation
  };

LagrangeBasisFunction<2> Square8class(Square8BF, Line3, quad8),
  *Square8 = &Square8class;

basisFunction<2> Square9BF =    // two-d biquadratic basis fns
  {9,
   {1,1,1},
   Line3,
   &Square,
   9,
   Square9Pts,
   identityPermutation
  };

LagrangeBasisFunction<2> Square9class(Square9BF, Line3, quad9),
 *Square9 = &Square9class;

svector<2> Square16Pts[] = {svector<2>(-1.0,-1.0), svector<2>( 1.0,-1.0), 
			    svector<2>( 1.0, 1.0), svector<2>(-1.0, 1.0),
			   
	svector<2>(-1.0/sqrt(5.0),-1.0), svector<2>( 1.0/sqrt(5.0), -1.0),
	svector<2>( 1.0,-1.0/sqrt(5.0)), svector<2>( 1.0,  1.0/sqrt(5.0)),
	svector<2>( 1.0/sqrt(5.0), 1.0), svector<2>(-1.0/sqrt(5.0),  1.0),
	svector<2>(-1.0, 1.0/sqrt(5.0)), svector<2>(-1.0, -1.0/sqrt(5.0)),

	svector<2>(-1.0/sqrt(5.0), -1.0/sqrt(5.0)), 
        svector<2>( 1.0/sqrt(5.0), -1.0/sqrt(5.0)),
	svector<2>( 1.0/sqrt(5.0),  1.0/sqrt(5.0)), 
        svector<2>(-1.0/sqrt(5.0),  1.0/sqrt(5.0))};

basisFunction<2> Square12BF =    // two-d serendipity cubic fns
  {12,
   {1,2,0},
   Line4,
   &Square,
   12,
   Square16Pts,                  // first 12 points are the same
   quad12Permutation
  };

LagrangeBasisFunction<2> Square12class(Square12BF, Line4, quad12),
 *Square12 = &Square12class;

basisFunction<2> Square16BF =    // two-d bicubic basis fns
  {16,
   {1,2,4},
   Line4,
   &Square,
   16,
   Square16Pts,
   quad16Permutation
  };

LagrangeBasisFunction<2> Square16class(Square16BF, Line4, quad16),
 *Square16 = &Square16class;

svector<2> Square17Pts[] = {svector<2>(-1.0,-1.0), svector<2>( 1.0,-1.0), 
			    svector<2>( 1.0, 1.0), svector<2>(-1.0, 1.0),
			   
  svector<2>(-sqrt(3.0/7.0),-1), svector<2>( 0,-1), svector<2>(sqrt(3.0/7.0),  -1),
  svector<2>( 1,-sqrt(3.0/7.0)), svector<2>( 1, 0), svector<2>( 1,  sqrt(3.0/7.0)),
  svector<2>( sqrt(3.0/7.0), 1), svector<2>( 0, 1), svector<2>(-sqrt(3.0/7.0),  1),
  svector<2>(-1, sqrt(3.0/7.0)), svector<2>(-1, 0), svector<2>(-1, -sqrt(3.0/7.0)),

  svector<2>(0.0, 0.0)};

basisFunction<2> Square17BF =    // two-d bicubic basis fns
  {17,
   {1,3,1},
   Line5,
   &Square,
   17,
   Square17Pts,
   quad17Permutation
  };

LagrangeBasisFunction<2> Square17class(Square17BF, Line5, quad17),
  *Square17 = &Square17class;

svector<2> Square24Pts[] = 
  {svector<2>(-1.0,-1.0), svector<2>( 1.0,-1.0), 
   svector<2>( 1.0, 1.0), svector<2>(-1.0, 1.0),

   svector<2>(-sqrt((3+2*sqrt(6.0/5))/7.0), -1),
   svector<2>(-sqrt((3-2*sqrt(6.0/5))/7.0), -1),
   svector<2>( sqrt((3-2*sqrt(6.0/5))/7.0), -1),
   svector<2>( sqrt((3+2*sqrt(6.0/5))/7.0), -1),

   svector<2>(1, -sqrt((3+2*sqrt(6.0/5))/7.0)),
   svector<2>(1, -sqrt((3-2*sqrt(6.0/5))/7.0)),
   svector<2>(1,  sqrt((3-2*sqrt(6.0/5))/7.0)),
   svector<2>(1,  sqrt((3+2*sqrt(6.0/5))/7.0)),

   svector<2>( sqrt((3+2*sqrt(6.0/5))/7.0), 1),
   svector<2>( sqrt((3-2*sqrt(6.0/5))/7.0), 1),
   svector<2>(-sqrt((3-2*sqrt(6.0/5))/7.0), 1),
   svector<2>(-sqrt((3+2*sqrt(6.0/5))/7.0), 1),

   svector<2>(-1,  sqrt((3+2*sqrt(6.0/5))/7.0)),
   svector<2>(-1,  sqrt((3-2*sqrt(6.0/5))/7.0)),
   svector<2>(-1, -sqrt((3-2*sqrt(6.0/5))/7.0)),
   svector<2>(-1, -sqrt((3+2*sqrt(6.0/5))/7.0)),

   svector<2>(-sqrt(3.0)/4.0, -sqrt(3.0)/4.0),
   svector<2>( sqrt(3.0)/4.0, -sqrt(3.0)/4.0),
   svector<2>( sqrt(3.0)/4.0,  sqrt(3.0)/4.0),
   svector<2>(-sqrt(3.0)/4.0,  sqrt(3.0)/4.0)};

basisFunction<2> Square24BF =    // two-d bicubic basis fns
  {24,
   {1,4,4},
   Line6,
   &Square,
   24,
   Square24Pts,
   quad24Permutation
  };

LagrangeBasisFunction<2> Square24class(Square24BF, Line6, quad24),
 *Square24 = &Square24class;

// ***************** 3d Functions on Cube **********************
// ***************** 3d Functions on Cube **********************
// ***************** 3d Functions on Cube **********************

svector<3> Cube27Pts[] = 
  {svector<3>(-1,-1,-1), svector<3>(1,-1,-1),  // vertices
   svector<3>(-1, 1,-1), svector<3>(1, 1,-1), 
   svector<3>(-1,-1, 1), svector<3>(1,-1, 1), 
   svector<3>(-1, 1, 1), svector<3>(1, 1, 1),
   svector<3>(0, -1,-1), svector<3>(0, 1, -1),  // mid edges
   svector<3>(0, -1, 1), svector<3>(0, 1, 1), 
   svector<3>(-1, 0,-1), svector<3>(1, 0,-1), 
   svector<3>(-1, 0, 1), svector<3>(1, 0, 1), 
   svector<3>(-1,-1, 0), svector<3>(1,-1, 0), 
   svector<3>(-1, 1, 0), svector<3>(1, 1, 0),
   svector<3>(0, 0, -1), svector<3>(0, 0, 1),  // mid faces 
   svector<3>(0, -1, 0), svector<3>(0, 1, 0), 
   svector<3>(-1, 0, 0), svector<3>(1, 0, 0),
   svector<3>( 0, 0, 0)};                      // center

basisFunction<3> Cube8BF =    // two-d biquadratic basis fns
  {8,
   {1,0,0,0},
   Square4,
   &Cube,
   8,
   Cube27Pts,           // Cube8, Cube20, Cube 27 interpolation points nest
   identityPermutation
  };

LagrangeBasisFunction<3> Cube8class(Cube8BF, Square4, cube8),
  *Cube8 = &Cube8class;

svector<3> Cube8BubblePts[] = 
  {svector<3>(-1,-1,-1), svector<3>(1,-1,-1),  // vertices
   svector<3>(-1, 1,-1), svector<3>(1, 1,-1), 
   svector<3>(-1,-1, 1), svector<3>(1,-1, 1), 
   svector<3>(-1, 1, 1), svector<3>(1, 1, 1),
   svector<3>( 0, 0, 0)};                      // center

basisFunction<3> Cube8BubbleBF =    // two-d biquadratic basis fns
  {9,
   {1,0,0,1},
   Square4,
   &Cube,
   8,                         // not clear how to initialize bubble
   Cube8BubblePts,
   identityPermutation,
  };

LagrangeBasisFunction<3> 
  Cube8BubbleClass(Cube8BubbleBF, Square4, cube8Bubble),
 *Cube8Bubble = &Cube8BubbleClass;

basisFunction<3> Cube20BF =    // two-d biquadratic basis fns
  {20,
   {1,1,0,0},
   Square8,
   &Cube,
   20,
   Cube27Pts,             // points same as first 20 tensor product
   identityPermutation
  };

LagrangeBasisFunction<3> Cube20class(Cube20BF, Square8, cube20),
  *Cube20 = &Cube20class;

basisFunction<3> Cube27BF =    // two-d biquadratic basis fns
  {27,
   {1,1,1,1},
   Square9,
   &Cube,
   27,
   Cube27Pts,
   identityPermutation,
  };

LagrangeBasisFunction<3> Cube27class(Cube27BF, Square9, cube27),
  *Cube27 = &Cube27class;

// ***************** 3d Functions on Tetrahedra **********************
// ***************** 3d Functions on Tetrahedra **********************
// ***************** 3d Functions on Tetrahedra **********************

svector<3> Tet10Pts[] = 
  {svector<3>(0, 0, 0), svector<3>(1, 0, 0),  // vertices
   svector<3>(0, 1, 0), svector<3>(0, 0, 1), 
   svector<3>(0.5, 0.0, 0.0), svector<3>(0.5, 0.5, 0.0),  // mid edges
   svector<3>(0.0, 0.5, 0.0), svector<3>(0.0, 0.0, 0.5), 
   svector<3>(0.5, 0.0, 0.5), svector<3>(0.0, 0.5, 0.5)};

basisFunction<3> Tet4BF =   
  {4,
   {1,0,0,0},
   Triangle3,
   &Tetrahedron,
   4,
   Tet10Pts,
   identityPermutation
  };

LagrangeBasisFunction<3> Tet4class(Tet4BF, Triangle3, tet4),
 *Tet4 = &Tet4class;

svector<3> Tet4BubblePts[] = 
  {svector<3>(0, 0, 0), svector<3>(1, 0, 0),  // vertices
   svector<3>(0, 1, 0), svector<3>(0, 0, 1), 
   svector<3>(1.0/4.0, 1.0/4.0, 1.0/4.0)};

basisFunction<3> Tet4BubbleBF =   
  {5,
   {1,0,0,1},
   Triangle3,
   &Tetrahedron,
   4,
   Tet4BubblePts,
   identityPermutation
  };

LagrangeBasisFunction<3> 
  Tet4BubbleClass(Tet4BubbleBF, Triangle3, tet4Bubble),
  *Tet4Bubble = &Tet4BubbleClass;

basisFunction<3> Tet10BF =  
  {10,
   {1,1,0,0},
   Triangle6,
   &Tetrahedron,
   10,
   Tet10Pts, 
   identityPermutation
  };

LagrangeBasisFunction<3> Tet10class(Tet10BF, Triangle6, tet10),
 *Tet10 = &Tet10class;

svector<3> Tet20Pts[] = 
  {svector<3>(0, 0, 0), svector<3>(1, 0, 0),  // vertices
   svector<3>(0, 1, 0), svector<3>(0, 0, 1), 

   svector<3>(0.5*(1-1.0/sqrt(5.0)), 0.0, 0.0),   // bottom edges
   svector<3>(0.5*(1+1.0/sqrt(5.0)), 0.0, 0.0),
   svector<3>(0.5*(1+1.0/sqrt(5.0)), 0.5*(1-1.0/sqrt(5.0)), 0.0), 
   svector<3>(0.5*(1-1.0/sqrt(5.0)), 0.5*(1+1.0/sqrt(5.0)), 0.0),
   svector<3>(0.0, 0.5*(1+1.0/sqrt(5.0)), 0.0), 
   svector<3>(0.0, 0.5*(1-1.0/sqrt(5.0)), 0.0),

   svector<3>(0.0, 0.0, 0.5*(1+1.0/sqrt(5.0))),   // edges from apex 
   svector<3>(0.0, 0.0, 0.5*(1-1.0/sqrt(5.0))),
   svector<3>(0.5*(1-1.0/sqrt(5.0)), 0.0, 0.5*(1+1.0/sqrt(5.0))),
   svector<3>(0.5*(1+1.0/sqrt(5.0)), 0.0, 0.5*(1-1.0/sqrt(5.0))), 
   svector<3>(0.0, 0.5*(1-1.0/sqrt(5.0)), 0.5*(1+1.0/sqrt(5.0))),
   svector<3>(0.0, 0.5*(1+1.0/sqrt(5.0)), 0.5*(1-1.0/sqrt(5.0))), 

   svector<3>(1.0/3.0, 1.0/3.0, 1.0/3.0),     // mid-faces
   svector<3>(0.0, 1.0/3.0, 1.0/3.0),
   svector<3>(1.0/3.0, 0.0, 1.0/3.0),
   svector<3>(1.0/3.0, 1.0/3.0, 0.0)};

basisFunction<3> Tet20BF =  
  {20,
   {1,2,1,0},
   Triangle10,
   &Tetrahedron,
   20,
   Tet20Pts, 
   tet20Permutation
  };

LagrangeBasisFunction<3> Tet20class(Tet20BF, Triangle10, tet20),
 *Tet20 = &Tet20class;

// ******************* basis functions ***************************
// ******************* basis functions ***************************
// ******************* basis functions ***************************

void line1(svector<1> peta, double psi[1], svector<1> dpsi[1])
{
  psi[0] = 1.0;  
  
  if(dpsi == NULL) return;

  dpsi[0] = 0.0; 

  return;
}

void line2(svector<1> peta, double psi[2], svector<1> dpsi[2])
{
  double eta = peta[0];

  psi[0] = (1-eta)/2.0;  
  psi[1] = (1+eta)/2.0; 
  
  if(dpsi == NULL) return;

  dpsi[0] = -0.5; 
  dpsi[1] =  0.5;

  return;
}

void line2bar(svector<1> peta, double psi[2], 
	      svector<1> dpsi[2], double psiBar[2])
{
  double eta = peta[0];

  psi[0] = (1-eta)/2.0;  
  psi[1] = (1+eta)/2.0; 

  if(dpsi == NULL) return;

  dpsi[0] = -0.5; 
  dpsi[1] =  0.5;

  psiBar[0] = psiBar[1] = 0.5;  // projections onto degree zero polys

  return;
}

void line3(svector<1> peta, double psi[3], svector<1> dpsi[3])
{
 double eta = peta[0];
 double ope = 1+eta, ome = 1-eta;

 psi[0] = -eta * ome / 2; 
 psi[1] =  eta * ope / 2; 
 psi[2] =  ope * ome    ; 

  if(dpsi == NULL) return;

  dpsi[0] = -0.5 + eta;
  dpsi[1] =  0.5 + eta;
  dpsi[2] = -2.0 * eta;

return;
}

void line3bar(svector<1> peta, double psi[3], 
	      svector<1> dpsi[3], double psiBar[3])
{
 double eta = peta[0];
 double ope = 1+eta, ome = 1-eta;

 psi[0] = -eta * ome / 2; 
 psi[1] =  eta * ope / 2; 
 psi[2] =  ope * ome    ; 

  if(dpsi == NULL) return;

  dpsi[0] = -0.5 + eta;
  dpsi[1] =  0.5 + eta;
  dpsi[2] = -2.0 * eta;

  psiBar[0] = 1.0/6.0 - 0.5*eta;     // projections onto degree one polys
  psiBar[1] = 1.0/6.0 + 0.5*eta;
  psiBar[2] = 2.0/3.0;

  return;
}

void line4(svector<1> pxi, double psi[4], svector<1> dpsi[4])
{
  double xi = pxi[0], xisq = xi*xi;
  double sqrt5 = sqrt(5.0), w1 = 5.0/8.0, w0 = sqrt5*w1;

// Use the Gauss Labotto Points -1, 1, -1/sqrt(5), 1/sqrt(5)

  psi[0] = w1 * (xisq - 1.0/5.0) * (1.0 - xi);
  psi[1] = w1 * (xisq - 1.0/5.0) * (1.0 + xi);
  psi[2] = w0 * (1.0 - xisq) * (1.0/sqrt5 - xi);
  psi[3] = w0 * (1.0 - xisq) * (1.0/sqrt5 + xi);
  
  if(dpsi == NULL) return;
  
  dpsi[0] = w1*(-3*xisq + 2*xi + 1.0/5.0);
  dpsi[1] = w1*( 3*xisq + 2*xi - 1.0/5.0);
  dpsi[2] = w0*( 3*xisq - (2/sqrt5)*xi - 1.0);
  dpsi[3] = w0*(-3*xisq - (2/sqrt5)*xi + 1.0);

// Old code used equispaced points, -1, 1, -1/3, 1/3

//   psi[0] = (9.0/16.0) * (xisq - 1.0/9.0) * (1.0 - xi);
//   psi[1] = (9.0/16.0) * (xisq - 1.0/9.0) * (1.0 + xi);
//   psi[2] = (27.0/16.0) * (1.0 - xisq) * (1.0/3.0 - xi);
//   psi[3] = (27.0/16.0) * (1.0 - xisq) * (1.0/3.0 + xi);

//  if(dpsi == NULL) return;
 
//   dpsi[0] =-(27.0/16.0)*xisq + (9.0/8.0)*xi + (1.0/16.0);
//   dpsi[1] = (27.0/16.0)*xisq + (9.0/8.0)*xi - (1.0/16.0);
//   dpsi[2] = (81.0/16.0)*xisq - (9.0/8.0)*xi - (27.0/16.0);
//   dpsi[3] =-(81.0/16.0)*xisq - (9.0/8.0)*xi + (27.0/16.0);

return;
}

void line4Permutation(const int *nodes, int *dof)
{
  if(nodes[0] > nodes[1])
    {
      int temp = dof[2]; dof[2] = dof[3]; dof[3] = temp;
    }

  return;
}

void line5(svector<1> pxi, double psi[5], svector<1> dpsi[5])
{
  double eta = pxi[0], gp =sqrt(21.0);
  double eta2 = eta*eta, eta3 = eta2*eta;
  double em1 = eta-1, ep1 = eta+1, esq7m3 = 7*eta2-3;

// Use the Gauss Labotto Points -1, 1, -sqrt(3/7), 0, sqrt(3/7)

  psi[0] = 0.125*eta*em1*esq7m3;
  psi[1] = 0.125*eta*ep1*esq7m3;
  psi[2] = (-7.0/24.0)*eta*em1*ep1*(7*eta-gp);
  psi[3] = ( 1.0/ 3.0)*em1*ep1*esq7m3;
  psi[4] = (-7.0/24.0)*eta*em1*ep1*(7*eta+gp);
  
  
  if(dpsi == NULL) return;
  
  dpsi[0] = svector<1>(3.5*eta3-0.75*eta-(21.0/8.0)*eta2+0.375);
  dpsi[1] = svector<1>(3.5*eta3+(21.0/8.0)*eta2-0.75*eta-0.375);
  dpsi[2] = svector<1>((-7.0/24.0)*(4*eta2-gp*eta+1)*(7*eta+gp));
  dpsi[3] = svector<1>(( 4.0/ 3.0)*eta*(-5+7*eta2));
  dpsi[4] = svector<1>((-7.0/24.0)*(4*eta2+gp*eta+1)*(7*eta-gp));
    
  return;
}

void line5Permutation(const int *nodes, int *dof)
{
  if(nodes[0] > nodes[1])
    {
      int temp = dof[2]; dof[2] = dof[4]; dof[4] = temp;
    }

  return;
}

void line6(svector<1> pxi, double psi[6], svector<1> dpsi[6])
{
  double s = pxi[0], sqrt30 = sqrt(30.0);
  double s2 = s*s, s3 = s2*s, s4 = s2*s2;
  double sm1 = s-1, sp1 = s+1;
  double pt1 = sqrt(525.0 + 70.0*sqrt30), pt2 = sqrt(525.0 - 70.0*sqrt30);

// Use the Gauss Labotto Points -1, 1, -pt1/35, -pt2/35, pt2/35, pt1/35
  
psi[0] = -(1.0/16)*sm1*(35*s4-30*s2+3);
psi[1] = (1.0/16)*sp1*(35*s4-30*s2+3);
psi[2] = -(1.0/117600)*pt1*(3*sqrt30-5)*(35*s2-15+2*sqrt30)*(-35*s+pt1)*sm1*sp1;
psi[3] = -(1.0/117600)*pt2*(5+3*sqrt30)*(-35*s2+15+2*sqrt30)*(-35*s+pt2)*sm1*sp1;
psi[4] = -(1.0/117600)*pt2*(5+3*sqrt30)*(-35*s2+15+2*sqrt30)*sm1*sp1*(35*s+pt2);
psi[5] = -(1.0/117600)*pt1*(3*sqrt30-5)*(35*s2-15+2*sqrt30)*(35*s+pt1)*sm1*sp1;

  if(dpsi == NULL) return;
  
dpsi[0] = svector<1>(-(175.0/16)*s4+(45.0/8)*s2-3.0/16+(35.0/4)*s3-(15.0/4)*s);
dpsi[1] = svector<1>((175.0/16)*s4-(45.0/8)*s2+3.0/16+(35.0/4)*s3-(15.0/4)*s);
dpsi[2] = svector<1>(-(1.0/117600)*pt1*(3*sqrt30-5)*(-525+70*sqrt30+140*s3*pt1+5250*s2-210*sqrt30*s2-6125*s4-100*pt1*s+4*pt1*sqrt30*s));
dpsi[3] = svector<1>(-(1.0/117600)*pt2*(5+3*sqrt30)*(70*sqrt30+525-140*s3*pt2-5250*s2-210*sqrt30*s2+6125*s4+100*s*pt2+4*s*sqrt30*pt2));
dpsi[4] = svector<1>(-(1.0/117600)*pt2*(5+3*sqrt30)*(-70*sqrt30-525-140*s3*pt2+5250*s2+210*sqrt30*s2-6125*s4+100*s*pt2+4*s*sqrt30*pt2));
dpsi[5] = svector<1> (-(1.0/117600)*pt1*(3*sqrt30-5)*(525-70*sqrt30+140*s3*pt1-5250*s2+210*s2*sqrt30+6125*s4-100*s*pt1+4*s*sqrt30*pt1));
  
  return;
}

void line6Permutation(const int *nodes, int *dof)
{
  if(nodes[0] > nodes[1])
    {
      int temp;
      temp = dof[2]; dof[2] = dof[5]; dof[5] = temp;
      temp = dof[3]; dof[3] = dof[4]; dof[4] = temp;
    }

  return;
}

void tri3(svector<2> xi, double sn[], svector<2> dsn[])
{
  double eta = xi[0], ata = xi[1], omema = 1.0-eta-ata;

  sn[0] = omema;  
  sn[1] = eta;    
  sn[2] = ata;    

 if(dsn == NULL) return;

 dsn[0] = svector<2>(-1,-1);
 dsn[1] = svector<2>(1,0);
 dsn[2] = svector<2>(0,1);
 
 return;
}

void tri3Bubble(svector<2> xi, double sn[4], svector<2> dsn[4])
{
  double eta = xi[0], ata = xi[1], omema = 1.0-eta-ata, bb = eta*ata;

  sn[0] = omema;  
  sn[1] = eta;    
  sn[2] = ata;    

  sn[3] = bb*omema;

 if(dsn == NULL) return;

 dsn[0] = svector<2>(-1,-1);
 dsn[1] = svector<2>(1,0);
 dsn[2] = svector<2>(0,1);
 
 dsn[3][0] = ata*omema - bb;
 dsn[3][1] = eta*omema - bb;

 return;
}

// This buble has the Lagrange interpolation property

void tri3BubbleInterp(svector<2> xi, double sn[4], svector<2> dsn[4])
{
  double eta = xi[0], ata = xi[1], omema = 1.0-eta-ata, bb = 9*omema*eta*ata;

  sn[0] = omema - bb;  
  sn[1] = eta   - bb;    
  sn[2] = ata   - bb;    

  sn[3] = 3.0 * bb;

 if(dsn == NULL) return;

 svector<2> db(9*ata*(omema - eta), 9*eta*(omema - ata));

 dsn[0] = svector<2>(-1,-1) - db;
 dsn[1] = svector<2>(1,0)   - db;
 dsn[2] = svector<2>(0,1)   - db;
 
 dsn[3] = 3.0 * db;

 return;
}

void tri6(svector<2> xi, double sn[], svector<2> dsn[])
{
  double eta = xi[0], ata = xi[1], omema = 1.0-eta-ata, hmema = 0.5-eta-ata;

  sn[0] = 2*omema*hmema;
  sn[1] = 2* eta *(eta-0.5);
  sn[2] = 2* ata *(ata-0.5);

  sn[3] = 4*eta*omema;
  sn[4] = 4*eta*ata;
  sn[5] = 4*ata*omema;

 if(dsn == NULL) return;
 
  dsn[0] = -2*(hmema+omema) * svector<2>(1.0,1.0);
  dsn[1] = svector<2>(4*eta-1, 0.0);
  dsn[2] = svector<2>(0.0, 4*ata-1);

  dsn[3] = 4 * svector<2>(1-2*eta-ata, -eta);
  dsn[4] = 4 * svector<2>(ata,eta);
  dsn[5] = 4 * svector<2>(-ata, 1-eta-2*ata);

  return;
}

void tri10Permutation(const int *nodes, int *dof)
{
  int temp;

  // permute the edge dof

  if(nodes[0] > nodes[1]) {temp = dof[3]; dof[3] = dof[4]; dof[4] = temp;}
  if(nodes[1] > nodes[2]) {temp = dof[5]; dof[5] = dof[6]; dof[6] = temp;}
  if(nodes[2] > nodes[0]) {temp = dof[7]; dof[7] = dof[8]; dof[8] = temp;}

  return;
}

 void tri10(svector<2> pt, double psi[10], svector<2> dpsi[10])
{
  // cubic serendipity square

  double xi = pt[0], eta = pt[1], eta2 = eta*eta, xi2 = xi*xi;
  double sqrt5 = sqrt(5.0);

psi[0] = -(xi-1+eta)*(5*xi2-5*xi+11*xi*eta-5*eta+5*eta2+1);
psi[1] = xi*(1-5*xi+eta+5*xi2-xi*eta-eta2);
psi[2] = -eta*(-1-xi+5*eta+xi2+xi*eta-5*eta2);
psi[3] = 0.5*sqrt5*(10*xi-sqrt5-5+3*eta*sqrt5+5*eta)*(xi-1+eta)*xi;
psi[4] = -0.5*sqrt5*(10*xi+sqrt5-5-3*eta*sqrt5+5*eta)*(xi-1+eta)*xi;
psi[5] = 1.25*(sqrt5+3)*(2*xi-3-3*eta*sqrt5+7*eta+sqrt5)*xi*eta;
psi[6] = -1.25*(sqrt5-3)*(2*xi-3+7*eta+3*eta*sqrt5-sqrt5)*xi*eta;
psi[7] = -1.25*(sqrt5-3)*(2*xi-3*eta*sqrt5-5*eta+sqrt5+1)*(xi-1+eta)*eta;
psi[8] = 1.25*(sqrt5+3)*(2*xi+3*eta*sqrt5-5*eta-sqrt5+1)*(xi-1+eta)*eta;
psi[9] = -27*xi*eta*(xi-1+eta);

 if(dpsi == NULL) return;

dpsi[0] = svector<2>(-15*xi2+20*xi-32*xi*eta+21*eta-16*eta2-6,
		  -16*xi2+21*xi-32*xi*eta+20*eta-15*eta2-6);
dpsi[1] = svector<2>(1-10*xi+eta+15*xi2-2*xi*eta-eta2,-xi*(-1+xi+2*eta));
dpsi[2] = svector<2>(-eta*(-1+2*xi+eta),1+xi-10*eta-xi2-2*xi*eta+15*eta2);
dpsi[3] = svector<2>(0.5*sqrt5*(30*xi2-30*xi+30*xi*eta-2*xi*sqrt5+6*xi*eta*sqrt5+sqrt5-4*eta*sqrt5+5-10*eta+3*eta2*sqrt5+5*eta2),
		  1.25*(sqrt5+1)*(6*xi-3-sqrt5+2*eta+2*eta*sqrt5)*xi);
dpsi[4] = svector<2>(-0.5*sqrt5*(30*xi2-30*xi+30*xi*eta+2*xi*sqrt5-6*xi*eta*sqrt5-sqrt5+4*eta*sqrt5+5-10*eta-3*eta2*sqrt5+5*eta2),
		  -1.25*(sqrt5-1)*(6*xi-3+sqrt5+2*eta-2*eta*sqrt5)*xi);
dpsi[5] = svector<2>(1.25*(sqrt5+3)*(7*eta-3*eta*sqrt5-3+4*xi+sqrt5)*eta,
		  1.25*(sqrt5+3)*(2*xi+sqrt5-3-6*eta*sqrt5+14*eta)*xi);
dpsi[6] = svector<2>(-1.25*(sqrt5-3)*(3*eta*sqrt5+7*eta-3+4*xi-sqrt5)*eta,
		  -1.25*(sqrt5-3)*(2*xi-3-sqrt5+14*eta+6*eta*sqrt5)*xi);
dpsi[7] = svector<2>(-1.25*(sqrt5-3)*(-3*eta-3*eta*sqrt5-1+sqrt5+4*xi)*eta,
		  -1.25*(sqrt5-3)*(-6*xi*eta-6*xi*eta*sqrt5+12*eta+8*eta*sqrt5-15*eta2-9*eta2*sqrt5+2*xi2+xi*sqrt5-xi-1-sqrt5));
dpsi[8] = svector<2>(1.25*(sqrt5+3)*(-sqrt5-1+4*xi-3*eta+3*eta*sqrt5)*eta,
		  1.25*(sqrt5+3)*(-6*xi*eta+6*xi*eta*sqrt5+12*eta-8*eta*sqrt5-15*eta2+9*eta2*sqrt5+2*xi2-xi*sqrt5-xi-1+sqrt5));
dpsi[9] = -27 * svector<2>(eta*(-1+2*xi+eta), xi*(-1+xi+2*eta));
  return;
}

void quad4(svector<2> xi, double psi[4], svector<2> dpsi[4])
{
  double eta = xi[0], ata = xi[1];
  double ope = (1+eta)/2, opa = (1+ata)/2;
  double ome = (1-eta)/2, oma = (1-ata)/2;

  psi[0] = ome * oma;
  psi[1] = ope * oma;
  psi[2] = ope * opa;
  psi[3] = ome * opa;

  if(dpsi == NULL) return;
 
  dpsi[0] = svector<2>(oma /-2, ome /-2);
  dpsi[1] = svector<2>(oma / 2, ope /-2);
  dpsi[2] = svector<2>(opa / 2, ope / 2);
  dpsi[3] = svector<2>(opa /-2, ome / 2);
  
  return;
}

void quad4Bubble(svector<2> xi, double psi[5], svector<2> dpsi[5])
{
  double eta = xi[0], ata = xi[1];
  double ope = (1+eta)/2, opa = (1+ata)/2;
  double ome = (1-eta)/2, oma = (1-ata)/2;

  double bb = (1-eta*eta)*(1-ata*ata), opepa = 1 + eta + ata;

  psi[0] = ome * oma;
  psi[1] = ope * oma;
  psi[2] = ope * opa;
  psi[3] = ome * opa;

  psi[4] = bb * opepa;  // bubble

  if(dpsi == NULL) return;
 
  dpsi[0] = svector<2>(oma /-2, ome /-2);
  dpsi[1] = svector<2>(oma / 2, ope /-2);
  dpsi[2] = svector<2>(opa / 2, ope / 2);
  dpsi[3] = svector<2>(opa /-2, ome / 2);

  dpsi[4][0] = bb - 2*eta*(1-ata*ata) * opepa;  // bubble
  dpsi[4][1] = bb - 2*ata*(1-eta*eta) * opepa;  // bubble
  
  return;
}

void quad8(svector<2> xi, double phi[8], svector<2> dphi[8])
{
  double eta = xi[0], ata = xi[1];
  double ope = 1+eta, opa = 1+ata, ome = 1-eta, oma = 1-ata;
  

  phi[0] = -0.25*ome*oma*(eta+ata+1);
  phi[1] =  0.25*ope*oma*(eta-ata-1);
  phi[2] =  0.25*ope*opa*(eta+ata-1);
  phi[3] = -0.25*ome*opa*(eta-ata+1);
  phi[4] =  0.5*ope*ome*oma;
  phi[5] =  0.5*oma*opa*ope;
  phi[6] =  0.5*ome*ope*opa;
  phi[7] =  0.5*oma*opa*ome;

  if(dphi == NULL) return;
 
  dphi[0] =  0.25* svector<2>(oma*(2*eta+ata), ome*(2*ata+eta));
  dphi[1] =  0.25* svector<2>(oma*(2*eta-ata), ope*(2*ata-eta));
  dphi[2] =  0.25* svector<2>(opa*(2*eta+ata), ope*(2*ata+eta));
  dphi[3] =  0.25* svector<2>(opa*(2*eta-ata), ome*(2*ata-eta));
  dphi[4] = -svector<2>(eta*oma, 0.5*ope*ome);
  dphi[5] =  svector<2>(0.5*oma*opa, -ata*ope);
  dphi[6] =  svector<2>(-eta*opa, 0.5*ome*ope);
  dphi[7] = -svector<2>(0.5*oma*opa,  ata*ome);
  
  return;
}   

void quad9(svector<2> xi, double phi[9], svector<2> dphi[9])
{
  double phi0e,phi1e,phi2e,dphi0e,dphi1e,dphi2e;
  double phi0a,phi1a,phi2a,dphi0a,dphi1a,dphi2a;
  double eta = xi[0], ata = xi[1];
  double ope = 1+eta, opa = 1+ata, ome = 1-eta, oma = 1-ata;
  
  phi0e =-eta * ome / 2; dphi0e =-0.5 + eta;
  phi1e = ope * ome;     dphi1e =-2.0 * eta;
  phi2e = eta * ope / 2; dphi2e = 0.5 + eta;
  
  phi0a =-ata * oma / 2; dphi0a =-0.5 + ata;
  phi1a = opa * oma;     dphi1a =-2.0 * ata;
  phi2a = ata * opa / 2; dphi2a = 0.5 + ata;
  
  phi[0] = phi0e*phi0a;
  phi[1] = phi2e*phi0a;
  phi[2] = phi2e*phi2a;
  phi[3] = phi0e*phi2a;
  
  phi[4] = phi1e*phi0a;
  phi[5] = phi2e*phi1a;
  phi[6] = phi1e*phi2a;
  phi[7] = phi0e*phi1a;
  
  phi[8] = phi1e*phi1a;  dphi[8] = svector<2>(dphi1e*phi1a, phi1e*dphi1a);
  
  if(dphi == NULL) return;
  
  dphi[0] = svector<2>(dphi0e*phi0a, phi0e*dphi0a);
  dphi[1] = svector<2>(dphi2e*phi0a, phi2e*dphi0a);
  dphi[2] = svector<2>(dphi2e*phi2a, phi2e*dphi2a);
  dphi[3] = svector<2>(dphi0e*phi2a, phi0e*dphi2a);
  
  dphi[4] = svector<2>(dphi1e*phi0a, phi1e*dphi0a);
  dphi[5] = svector<2>(dphi2e*phi1a, phi2e*dphi1a);
  dphi[6] = svector<2>(dphi1e*phi2a, phi1e*dphi2a);
  dphi[7] = svector<2>(dphi0e*phi1a, phi0e*dphi1a);
  
  dphi[8] = svector<2>(dphi1e*phi1a, phi1e*dphi1a);
  
  return;
}

void quad12(svector<2> xi, double psi[12], svector<2> dpsi[12])
{
  // cubic serendipity square

  double eta = xi[0], ata = xi[1], eta2 = eta*eta, ata2 = ata*ata;
  double one16 = 1.0/16.0, sqrt5 = sqrt(5.0), rt5o16 = sqrt5*one16;

  psi[0] =  one16*(-1+eta)*(-1+ata)*(5*ata2+5*eta2-6);
  psi[1] = -one16*( 1+eta)*(-1+ata)*(5*ata2+5*eta2-6);
  psi[2] =  one16*( 1+eta)*( 1+ata)*(5*ata2+5*eta2-6);
  psi[3] = -one16*(-1+eta)*( 1+ata)*(5*ata2+5*eta2-6);

  psi[4] =  rt5o16*(-1+ata)*(-1+eta)*(1+eta)*(-5*eta+sqrt5);
  psi[5] =  rt5o16*(-1+ata)*(-1+eta)*(1+eta)*(5*eta+sqrt5);
  psi[6] = -rt5o16*(-1+ata)*(-5*ata+sqrt5)*(1+ata)*(1+eta);
  psi[7] = -rt5o16*(-1+ata)*( 5*ata+sqrt5)*(1+ata)*(1+eta);
  psi[8] = -rt5o16*( 1+ata)*(-1+eta)*(1+eta)*(5*eta+sqrt5);
  psi[9] = -rt5o16*( 1+ata)*(-5*eta+sqrt5)*(-1+eta)*(1+eta);
  psi[10] = rt5o16*(5*ata+sqrt5)*(-1+ata)*(1+ata)*(-1+eta);
  psi[11] = rt5o16*(-1+ata)*(1+ata)*(-5*ata+sqrt5)*(-1+eta);

  if(dpsi == NULL) return;
  
  dpsi[0] = svector<2>(one16*(-1+ata)*(5*ata2+15*eta2-10*eta-6), 
		       one16*(-1+eta)*(5*eta2-6+15*ata2-10*ata));
  dpsi[1] = svector<2>(-one16*(-1+ata)*(5*ata2+15*eta2+10*eta-6), 
		       -one16*(1+eta)*(5*eta2-6+15*ata2-10*ata));
  dpsi[2] = svector<2>(one16*(1+ata)*(5*ata2+15*eta2+10*eta-6), 
		       one16*(1+eta)*(5*eta2+15*ata2-6+10*ata));
  dpsi[3] = svector<2>(-one16*(1+ata)*(5*ata2+15*eta2-10*eta-6), 
		       -one16*(-1+eta)*(5*eta2+15*ata2-6+10*ata));
  dpsi[4] = svector<2>(rt5o16*(-1+ata)*(-3*eta+sqrt5)*(5*eta+sqrt5), 
		       rt5o16*(-1+eta)*(1+eta)*(-5*eta+sqrt5));
  dpsi[5] = svector<2>(-rt5o16*(-1+ata)*(3*eta+sqrt5)*(-5*eta+sqrt5), 
		       rt5o16*(-1+eta)*(1+eta)*(5*eta+sqrt5));
  dpsi[6] = svector<2>(- rt5o16*(-1+ata)*(1+ata)*(-5*ata+sqrt5), 
		       -rt5o16*(-3*ata+sqrt5)*(5*ata+sqrt5)*(1+eta));
  dpsi[7] = svector<2>(-rt5o16*(-1+ata)*(5*ata+sqrt5)*(1+ata), 
		       rt5o16*(3*ata+sqrt5)*(-5*ata+sqrt5)*(1+eta));
  dpsi[8] = svector<2>(rt5o16*(1+ata)*(3*eta+sqrt5)*(-5*eta+sqrt5), 
		       -rt5o16*(-1+eta)*(1+eta)*(5*eta+sqrt5));
  dpsi[9] = svector<2>(-rt5o16*(1+ata)*(-3*eta+sqrt5)*(5*eta+sqrt5), 
		       -rt5o16*(-1+eta)*(1+eta)*(-5*eta+sqrt5));
  dpsi[10] = svector<2>(rt5o16*(-1+ata)*(5*ata+sqrt5)*(1+ata), 
			-rt5o16*(3*ata+sqrt5)*(-5*ata+sqrt5)*(-1+eta));
  dpsi[11] = svector<2>(rt5o16*(-1+ata)*(1+ata)*(-5*ata+sqrt5), 
			rt5o16*(-3*ata+sqrt5)*(5*ata+sqrt5)*(-1+eta));

  return;
}

void quad12Permutation(const int *nodes, int *dof)
{
  int temp;

  // permute the edge dof

  if(nodes[0] > nodes[1]) {temp = dof[ 4]; dof[ 4] = dof[ 5]; dof[ 5] = temp;}
  if(nodes[1] > nodes[2]) {temp = dof[ 6]; dof[ 6] = dof[ 7]; dof[ 7] = temp;}
  if(nodes[2] > nodes[3]) {temp = dof[ 8]; dof[ 8] = dof[ 9]; dof[ 9] = temp;}
  if(nodes[3] > nodes[0]) {temp = dof[10]; dof[10] = dof[11]; dof[11] = temp;}

  return;
}
	   
void quad16(svector<2> xi, double phi[16], svector<2> dphi[16])
{
  int i,j;
  int idx[4][4] = {{0,3,11,10},{1,2,6,7},{4,9,12,15},{5,8,13,14}};

  double eta = xi[0], ata = xi[1];
  double phix[4], dphix[4], phiy[4], dphiy[4];

  svector<1> vdphix[4], vdphiy[4];

  line4(eta, phix, vdphix);
  line4(ata, phiy, vdphiy);

  for(i = 0; i < 4; i++)
    {
      dphix[i] = vdphix[i][0];
      dphiy[i] = vdphiy[i][0];
    }

  for(i = 0; i < 4; i++)
  for(j = 0; j < 4; j++)
    {
      phi[idx[i][j]] = phix[i] * phiy[j];

      if(dphi != NULL)
	dphi[idx[i][j]] = svector<2>(dphix[i]*phiy[j], phix[i]*dphiy[j]);
    }

  return;
}

void quad16Permutation(const int *nodes, int *dof)
{
  int temp;

  // permute the edge dof

  if(nodes[0] > nodes[1]) {temp = dof[ 4]; dof[ 4] = dof[ 5]; dof[ 5] = temp;}
  if(nodes[1] > nodes[2]) {temp = dof[ 6]; dof[ 6] = dof[ 7]; dof[ 7] = temp;}
  if(nodes[2] > nodes[3]) {temp = dof[ 8]; dof[ 8] = dof[ 9]; dof[ 9] = temp;}
  if(nodes[3] > nodes[0]) {temp = dof[10]; dof[10] = dof[11]; dof[11] = temp;}

  // permute the cell dof

  int nn[4];
  for(int i = 0; i < 4; i++) nn[i] = nodes[i];
  sortDof(4, nn, dof+12);

  return;
}

void quad17(svector<2> xi, double psi[17], svector<2> dpsi[17])
{
  // quartic serendipity square

  double eta = xi[0], ata = xi[1], sqrt21 = sqrt(21.0);
  double eta2 = eta *eta, ata2 = ata *ata;
  double eta3 = eta2*eta, ata3 = ata2*ata;
  double ome = 1-eta, ope = 1+eta, oma = 1-ata, opa = 1+ata;

  psi[0] = -(1.0/16)*oma*ome*(7*eta3-4*ata*eta-7*eta+7*ata3-7*ata);
  psi[1] =  (1.0/16)*oma*ope*(7*eta3-4*ata*eta-7*eta-7*ata3+7*ata);
  psi[2] =  (1.0/16)*opa*ope*(7*eta3+4*ata*eta-7*eta+7*ata3-7*ata);
  psi[3] = -(1.0/16)*opa*ome*(7*eta3+4*ata*eta-7*eta-7*ata3+7*ata);
  psi[4] = -(7.0/48)*(-7*eta+sqrt21)*ope*ome*eta*oma;
  psi[5] = -(1.0/6)*oma*ome*ope*(7*eta2+3*ata);
  psi[6] =  (7.0/48)*(7*eta+sqrt21)*ope*ome*eta*oma;
  psi[7] = -(7.0/48)*ope*oma*opa*ata*(-7*ata+sqrt21);
  psi[8] =  (1.0/6)*oma*opa*ope*(3*eta-7*ata2);
  psi[9] =  (7.0/48)*ope*oma*opa*ata*(7*ata+sqrt21);
  psi[10] = (7.0/48)*ope*(7*eta+sqrt21)*ome*eta*opa;
  psi[11] = -(1.0/6)*opa*ome*ope*(7*eta2-3*ata);
  psi[12] = -(7.0/48)*(-7*eta+sqrt21)*ope*ome*eta*opa;
  psi[13] =  (7.0/48)*ome*oma*opa*(7*ata+sqrt21)*ata;
  psi[14] = -(1.0/6)*oma*opa*ome*(3*eta+7*ata2);
  psi[15] = -(7.0/48)*ome*(-7*ata+sqrt21)*oma*opa*ata;
  psi[16] =  oma*opa*ome*ope;
  
  if(dpsi == NULL) return;
 
  dpsi[0] = svector<2>(-(1.0/16)*(-1+ata)*(7*ata3-3*ata-8*ata*eta-21*eta2+7-14*eta+28*eta3),
		       -(1.0/16)*(-1+eta)*(7*eta3-8*ata*eta-3*eta+28*ata3-14*ata+7-21*ata2));
  dpsi[1] = svector<2>(-(1.0/16)*(-1+ata)*(-7*ata3+3*ata-8*ata*eta+21*eta2-7-14*eta+28*eta3), 
		       -(1.0/16)*(1+eta)*(7*eta3-8*ata*eta-3*eta+14*ata+21*ata2-7-28*ata3));
  dpsi[2] = svector<2>((1.0/16)*(1+ata)*(7*ata3-3*ata+8*ata*eta+28*eta3+21*eta2-14*eta-7), 
		       (1.0/16)*(1+eta)*(7*eta3+8*ata*eta-3*eta-14*ata+21*ata2-7+28*ata3));
  dpsi[3] = svector<2>((1.0/16)*(1+ata)*(-7*ata3+3*ata+8*ata*eta+28*eta3-21*eta2-14*eta+7), 
		       (1.0/16)*(-1+eta)*(7*eta3+8*ata*eta-3*eta+14*ata-21*ata2+7-28*ata3));
  dpsi[4] = svector<2>(-(7.0/48)*(-4*eta2+4.582575695*eta-1)*(7*eta+4.582575695)*(-1+ata), 
		       -(7.0/48)*eta*(1+eta)*(-7*eta+4.582575695)*(-1+eta));
  dpsi[5] = svector<2>(-(1.0/3)*eta*(-1+ata)*(3*ata-7+14*eta2), 
		       -(1.0/6)*(-1+eta)*(1+eta)*(7*eta2+6*ata-3));
  dpsi[6] = svector<2>(-(7.0/48)*(4*eta2+4.582575695*eta+1)*(-7*eta+4.582575695)*(-1+ata), 
	  	        (7.0/48)*eta*(1+eta)*(7*eta+4.582575695)*(-1+eta));
  dpsi[7] = svector<2>((7.0/48)*(-7*ata+4.582575695)*ata*(-1+ata)*(1+ata), 
		       (7.0/48)*(1+eta)*(-4*ata2+4.582575695*ata-1)*(7*ata+4.582575695));
  dpsi[8] = svector<2>(-(1.0/6)*(-1+ata)*(1+ata)*(-7*ata2+3+6*eta), 
		       -(1.0/3)*ata*(1+eta)*(3*eta+7-14*ata2));
  dpsi[9] = svector<2>(-(7.0/48)*ata*(7*ata+4.582575695)*(-1+ata)*(1+ata), 
		       (7.0/48)*(1+eta)*(4*ata2+4.582575695*ata+1)*(-7*ata+4.582575695));
  dpsi[10] = svector<2>((7.0/48)*(4*eta2+4.582575695*eta+1)*(-7*eta+4.582575695)*(1+ata), 
			-(7.0/48)*eta*(1+eta)*(7*eta+4.582575695)*(-1+eta));
  dpsi[11] = svector<2>((1.0/3)*eta*(1+ata)*(-3*ata+14*eta2-7), 
			(1.0/6)*(-1+eta)*(1+eta)*(7*eta2-6*ata-3));
  dpsi[12] = svector<2>((7.0/48)*(-4*eta2+4.582575695*eta-1)*(7*eta+4.582575695)*(1+ata), 
			(7.0/48)*eta*(1+eta)*(-7*eta+4.582575695)*(-1+eta));
  dpsi[13] = svector<2>((7.0/48)*ata*(7*ata+4.582575695)*(-1+ata)*(1+ata), 
			-(7.0/48)*(-1+eta)*(4*ata2+4.582575695*ata+1)*(-7*ata+4.582575695));
  dpsi[14] = svector<2>(-(1.0/6)*(-1+ata)*(1+ata)*(7*ata2-3+6*eta), 
			-(1.0/3)*ata*(-1+eta)*(3*eta-7+14*ata2));
  dpsi[15] = svector<2>(-(7.0/48)*(-7*ata+4.582575695)*ata*(-1+ata)*(1+ata), 
			-(7.0/48)*(-1+eta)*(-4*ata2+4.582575695*ata-1)*(7*ata+4.582575695));
  dpsi[16] = 2*svector<2>(eta*(-1+ata)*(1+ata), ata*(-1+eta)*(1+eta));
  
  return;
}

void quad17Permutation(const int *nodes, int *dof)
{
  int temp;

  // permute the edge dof

  if(nodes[0] > nodes[1]) {temp = dof[ 4]; dof[ 4] = dof[ 6]; dof[ 6] = temp;}
  if(nodes[1] > nodes[2]) {temp = dof[ 7]; dof[ 7] = dof[ 9]; dof[ 9] = temp;}
  if(nodes[2] > nodes[3]) {temp = dof[10]; dof[10] = dof[12]; dof[12] = temp;}
  if(nodes[3] > nodes[0]) {temp = dof[13]; dof[13] = dof[15]; dof[15] = temp;}

  return;
}

void quad24(svector<2> xi, double psi[24], svector<2> dpsi[24])
{
  // quintic serendipity square

  double s = xi[0], t = xi[1], sqrt3 = sqrt(3.0), sqrt30 = sqrt(30.0);
  double s2 = s *s,  t2 = t *t;
  double s3 = s2*s,  t3 = t2*t;
  double s4 = s2*s2, t4 = t2*t2;
  double sm1 = s-1, sp1 = s+1, tm1 = t-1, tp1 = t+1;
  double pt1 = sqrt(525.0 + 70.0*sqrt30), pt2 = sqrt(525.0 - 70.0*sqrt30);

psi[0] = (1.0/5408)*(2424-7832*s2-7832*t2+5915*s4+5915*t4+2762*s2*t2)*tm1*sm1;
psi[1] = -(1.0/5408)*(2424-7832*s2-7832*t2+5915*s4+5915*t4+2762*s2*t2)*tm1*sp1;
psi[2] = (1.0/5408)*(2424-7832*s2-7832*t2+5915*s4+5915*t4+2762*s2*t2)*tp1*sp1;
psi[3] = -(1.0/5408)*(2424-7832*s2-7832*t2+5915*s4+5915*t4+2762*s2*t2)*tp1*sm1;
psi[4] = -(1.0/218312640)*pt1*(113*sqrt30-711)*(-78*sqrt30-396+416*sqrt30*s2+1755*s2+357*t2)*tm1*sm1*sp1*(-35*s+pt1);
psi[5] = -(1.0/218312640)*pt2*(711+113*sqrt30)*(396-78*sqrt30-1755*s2+416*sqrt30*s2-357*t2)*tm1*(-35*s+pt2)*sm1*sp1;
psi[6] = -(1.0/218312640)*pt2*(711+113*sqrt30)*(396-78*sqrt30-1755*s2+416*sqrt30*s2-357*t2)*tm1*sm1*sp1*(35*s+pt2);
psi[7] = -(1.0/218312640)*pt1*(113*sqrt30-711)*(-78*sqrt30-396+416*sqrt30*s2+1755*s2+357*t2)*tm1*sm1*sp1*(35*s+pt1);
psi[8] = -(1.0/3057600)*pt1*(3*sqrt30-5)*(-6*sqrt30-60-135*s2+32*sqrt30*s2+455*t2)*tp1*tm1*(-35*t+pt1)*sp1;
psi[9] = -(1.0/3057600)*pt2*(3*sqrt30+5)*(-455*t2+60-6*sqrt30+32*sqrt30*s2+135*s2)*tp1*tm1*(-35*t+pt2)*sp1;
psi[10] = -(1.0/3057600)*pt2*(3*sqrt30+5)*(-455*t2+60-6*sqrt30+32*sqrt30*s2+135*s2)*tp1*tm1*(35*t+pt2)*sp1;
psi[11] = -(1.0/3057600)*pt1*(3*sqrt30-5)*(-6*sqrt30-60-135*s2+32*sqrt30*s2+455*t2)*tp1*(35*t+pt1)*tm1*sp1;
psi[12] = (1.0/218312640)*pt1*(113*sqrt30-711)*(-78*sqrt30-396+416*sqrt30*s2+1755*s2+357*t2)*tp1*sm1*sp1*(35*s+pt1);
psi[13] = (1.0/218312640)*pt2*(711+113*sqrt30)*(396-78*sqrt30-1755*s2+416*sqrt30*s2-357*t2)*tp1*sm1*sp1*(35*s+pt2);
psi[14] = (1.0/218312640)*pt2*(711+113*sqrt30)*(396-78*sqrt30-1755*s2+416*sqrt30*s2-357*t2)*tp1*(-35*s+pt2)*sm1*sp1;
psi[15] = (1.0/218312640)*pt1*(113*sqrt30-711)*(-78*sqrt30-396+416*sqrt30*s2+1755*s2+357*t2)*tp1*sm1*sp1*(-35*s+pt1);
psi[16] = (1.0/3057600)*pt1*(3*sqrt30-5)*(-6*sqrt30-60-135*s2+32*sqrt30*s2+455*t2)*tp1*tm1*(35*t+pt1)*sm1;
psi[17] = (1.0/3057600)*pt2*(3*sqrt30+5)*(-455*t2+60-6*sqrt30+32*sqrt30*s2+135*s2)*(35*t+pt2)*tp1*tm1*sm1;
psi[18] = (1.0/3057600)*pt2*(3*sqrt30+5)*(-455*t2+60-6*sqrt30+32*sqrt30*s2+135*s2)*tp1*tm1*(-35*t+pt2)*sm1;
psi[19] = (1.0/3057600)*pt1*(3*sqrt30-5)*(-6*sqrt30-60-135*s2+32*sqrt30*s2+455*t2)*tp1*(-35*t+pt1)*tm1*sm1;
psi[20] = (64.0/507)*tm1*tp1*(-4*t+sqrt3)*sm1*sp1*(-4*s+sqrt3);
psi[21] = (64.0/507)*tp1*(-4*t+sqrt3)*tm1*(4*s+sqrt3)*sm1*sp1;
psi[22] = (64.0/507)*tm1*tp1*(4*t+sqrt3)*sm1*sp1*(4*s+sqrt3);
psi[23] = (64.0/507)*tp1*(4*t+sqrt3)*tm1*sm1*sp1*(-4*s+sqrt3);

  if(dpsi == NULL) return;

dpsi[0] = svector<2>((1.0/5408)*tm1*(5915*t4-5524*s*t2+8286*s2*t2-7832*t2-23496*s2+15664*s+29575*s4-23660*s3+2424), (1.0/5408)*sm1*(5915*s4+8286*s2*t2-5524*s2*t-7832*s2-23496*t2-23660*t3+29575*t4+2424+15664*t));
dpsi[1] = svector<2>(-(1.0/5408)*tm1*(5915*t4+5524*s*t2+8286*s2*t2-7832*t2-23496*s2-15664*s+29575*s4+23660*s3+2424), -(1.0/5408)*sp1*(5915*s4+8286*s2*t2-5524*s2*t-7832*s2-23496*t2-23660*t3+29575*t4+2424+15664*t));
dpsi[2] = svector<2>((1.0/5408)*tp1*(5915*t4+5524*s*t2+8286*s2*t2-7832*t2-23496*s2-15664*s+29575*s4+23660*s3+2424), (1.0/5408)*sp1*(5915*s4+8286*s2*t2+5524*s2*t-7832*s2+2424-15664*t-23496*t2+23660*t3+29575*t4));
dpsi[3] = svector<2>(-(1.0/5408)*tp1*(5915*t4-5524*s*t2+8286*s2*t2-7832*t2-23496*s2+15664*s+29575*s4-23660*s3+2424), -(1.0/5408)*sm1*(5915*s4+8286*s2*t2+5524*s2*t-7832*s2+2424-15664*t-23496*t2+23660*t3+29575*t4));
dpsi[4] = svector<2>(-(1.0/218312640)*pt1*(113*sqrt30-711)*(225855*s2+12495*t2-307125*s4-2730*sqrt30-37485*s2*t2-4302*s*pt1+7020*s3*pt1-13860+1664*sqrt30*s3*pt1+714*pt1*t2*s-988*sqrt30*s*pt1-72800*sqrt30*s4+51870*sqrt30*s2)*tm1, -(1.0/218312640)*pt1*(113*sqrt30-711)*(-396-78*sqrt30+416*sqrt30*s2+1755*s2+1071*t2-714*t)*sm1*sp1*(-35*s+pt1));
dpsi[5] = svector<2>(-(1.0/218312640)*pt2*(711+113*sqrt30)*(-714*t2*s*pt2-225855*s2-12495*t2+307125*s4-2730*sqrt30+37485*s2*t2-988*sqrt30*s*pt2+13860-72800*sqrt30*s4+4302*s*pt2+51870*sqrt30*s2+1664*sqrt30*s3*pt2-7020*s3*pt2)*tm1, -(1.0/218312640)*pt2*(711+113*sqrt30)*(396-78*sqrt30+416*sqrt30*s2-1755*s2-1071*t2+714*t)*sm1*sp1*(-35*s+pt2));
dpsi[6] = svector<2>(-(1.0/218312640)*pt2*(711+113*sqrt30)*(-714*t2*s*pt2+225855*s2+12495*t2-307125*s4+2730*sqrt30-37485*s2*t2-988*sqrt30*s*pt2-13860+72800*sqrt30*s4+4302*s*pt2-51870*sqrt30*s2+1664*sqrt30*s3*pt2-7020*s3*pt2)*tm1, -(1.0/218312640)*pt2*(711+113*sqrt30)*(396-78*sqrt30+416*sqrt30*s2-1755*s2-1071*t2+714*t)*sm1*(35*s+pt2)*sp1);
dpsi[7] = svector<2>(-(1.0/218312640)*pt1*(113*sqrt30-711)*(-225855*s2-12495*t2+307125*s4+2730*sqrt30+37485*s2*t2-4302*s*pt1+7020*s3*pt1+13860+1664*sqrt30*s3*pt1+714*pt1*t2*s-988*sqrt30*s*pt1+72800*sqrt30*s4-51870*sqrt30*s2)*tm1, -(1.0/218312640)*pt1*(113*sqrt30-711)*(-396-78*sqrt30+416*sqrt30*s2+1755*s2+1071*t2-714*t)*sm1*sp1*(35*s+pt1));
dpsi[8] = svector<2>(-(1.0/3057600)*pt1*(3*sqrt30-5)*(-60-6*sqrt30-405*s2+96*sqrt30*s2+455*t2-270*s+64*sqrt30*s)*tp1*tm1*(-35*t+pt1), -(1.0/3057600)*pt1*(3*sqrt30-5)*(-2100-210*sqrt30+1120*sqrt30*s2-4725*s2+630*sqrt30*t2+54075*t2+1820*pt1*t3-79625*t4-1030*pt1*t-12*pt1*sqrt30*t-270*s2*pt1*t+64*sqrt30*s2*pt1*t+14175*s2*t2-3360*sqrt30*s2*t2)*sp1);
dpsi[9] = svector<2>(-(1.0/3057600)*pt2*(3*sqrt30+5)*(60-6*sqrt30+405*s2+96*sqrt30*s2-455*t2+64*sqrt30*s+270*s)*tp1*tm1*(-35*t+pt2), -(1.0/3057600)*pt2*(3*sqrt30+5)*(2100-210*sqrt30+4725*s2+1120*sqrt30*s2-54075*t2+630*sqrt30*t2-1820*pt2*t3+79625*t4+1030*pt2*t-12*pt2*sqrt30*t+64*sqrt30*s2*pt2*t+270*s2*pt2*t-14175*s2*t2-3360*sqrt30*s2*t2)*sp1);
dpsi[10] = svector<2>(-(1.0/3057600)*pt2*(3*sqrt30+5)*(60-6*sqrt30+405*s2+96*sqrt30*s2-455*t2+64*sqrt30*s+270*s)*tp1*(35*t+pt2)*tm1, -(1.0/3057600)*pt2*(3*sqrt30+5)*(-2100+210*sqrt30-4725*s2-1120*sqrt30*s2+54075*t2-630*sqrt30*t2-1820*pt2*t3-79625*t4+1030*pt2*t-12*pt2*sqrt30*t+64*sqrt30*s2*pt2*t+270*s2*pt2*t+14175*s2*t2+3360*sqrt30*s2*t2)*sp1);
dpsi[11] = svector<2>(-(1.0/3057600)*pt1*(3*sqrt30-5)*(-60-6*sqrt30-405*s2+96*sqrt30*s2+455*t2-270*s+64*sqrt30*s)*tp1*(35*t+pt1)*tm1, -(1.0/3057600)*pt1*(3*sqrt30-5)*(2100+210*sqrt30-1120*sqrt30*s2+4725*s2-630*sqrt30*t2-54075*t2+1820*pt1*t3+79625*t4-12*pt1*sqrt30*t-1030*pt1*t+64*sqrt30*s2*pt1*t-270*s2*pt1*t-14175*s2*t2+3360*sqrt30*s2*t2)*sp1);
dpsi[12] = svector<2>((1.0/218312640)*pt1*(113*sqrt30-711)*(-225855*s2-12495*t2+307125*s4+2730*sqrt30+37485*s2*t2-4302*s*pt1+7020*s3*pt1+13860+1664*sqrt30*s3*pt1+714*pt1*t2*s-988*sqrt30*s*pt1+72800*sqrt30*s4-51870*sqrt30*s2)*tp1, (1.0/218312640)*pt1*(113*sqrt30-711)*(-396-78*sqrt30+416*sqrt30*s2+1755*s2+1071*t2+714*t)*sm1*sp1*(35*s+pt1));
dpsi[13] = svector<2>((1.0/218312640)*pt2*(711+113*sqrt30)*(-714*t2*s*pt2+225855*s2+12495*t2-307125*s4+2730*sqrt30-37485*s2*t2-988*sqrt30*s*pt2-13860+72800*sqrt30*s4+4302*s*pt2-51870*sqrt30*s2+1664*sqrt30*s3*pt2-7020*s3*pt2)*tp1, (1.0/218312640)*pt2*(711+113*sqrt30)*(396-78*sqrt30+416*sqrt30*s2-1755*s2-1071*t2-714*t)*sm1*(35*s+pt2)*sp1);
dpsi[14] = svector<2>((1.0/218312640)*pt2*(711+113*sqrt30)*(-714*t2*s*pt2-225855*s2-12495*t2+307125*s4-2730*sqrt30+37485*s2*t2-988*sqrt30*s*pt2+13860-72800*sqrt30*s4+4302*s*pt2+51870*sqrt30*s2+1664*sqrt30*s3*pt2-7020*s3*pt2)*tp1, (1.0/218312640)*pt2*(711+113*sqrt30)*(396-78*sqrt30+416*sqrt30*s2-1755*s2-1071*t2-714*t)*sm1*sp1*(-35*s+pt2));
dpsi[15] = svector<2>((1.0/218312640)*pt1*(113*sqrt30-711)*(225855*s2+12495*t2-307125*s4-2730*sqrt30-37485*s2*t2-4302*s*pt1+7020*s3*pt1-13860+1664*sqrt30*s3*pt1+714*pt1*t2*s-988*sqrt30*s*pt1-72800*sqrt30*s4+51870*sqrt30*s2)*tp1, (1.0/218312640)*pt1*(113*sqrt30-711)*(-396-78*sqrt30+416*sqrt30*s2+1755*s2+1071*t2+714*t)*(-35*s+pt1)*sm1*sp1);
dpsi[16] = svector<2>((1.0/3057600)*pt1*(3*sqrt30-5)*(-60-6*sqrt30-405*s2+96*sqrt30*s2+455*t2+270*s-64*sqrt30*s)*tp1*(35*t+pt1)*tm1, (1.0/3057600)*pt1*(3*sqrt30-5)*(2100+210*sqrt30-1120*sqrt30*s2+4725*s2-630*sqrt30*t2-54075*t2+1820*pt1*t3+79625*t4-12*pt1*sqrt30*t-1030*pt1*t+64*sqrt30*s2*pt1*t-270*s2*pt1*t-14175*s2*t2+3360*sqrt30*s2*t2)*sm1);
dpsi[17] = svector<2>((1.0/3057600)*pt2*(3*sqrt30+5)*(60-6*sqrt30+405*s2+96*sqrt30*s2-455*t2-64*sqrt30*s-270*s)*tp1*tm1*(35*t+pt2), (1.0/3057600)*pt2*(3*sqrt30+5)*(-2100+210*sqrt30-4725*s2-1120*sqrt30*s2+54075*t2-630*sqrt30*t2-1820*pt2*t3-79625*t4+1030*pt2*t-12*pt2*sqrt30*t+64*sqrt30*s2*pt2*t+270*s2*pt2*t+14175*s2*t2+3360*sqrt30*s2*t2)*sm1);
dpsi[18] = svector<2>((1.0/3057600)*pt2*(3*sqrt30+5)*(60-6*sqrt30+405*s2+96*sqrt30*s2-455*t2-64*sqrt30*s-270*s)*tp1*tm1*(-35*t+pt2), (1.0/3057600)*pt2*(3*sqrt30+5)*(2100-210*sqrt30+4725*s2+1120*sqrt30*s2-54075*t2+630*sqrt30*t2-1820*pt2*t3+79625*t4+1030*pt2*t-12*pt2*sqrt30*t+64*sqrt30*s2*pt2*t+270*s2*pt2*t-14175*s2*t2-3360*sqrt30*s2*t2)*sm1);
dpsi[19] = svector<2>((1.0/3057600)*pt1*(3*sqrt30-5)*(-60-6*sqrt30-405*s2+96*sqrt30*s2+455*t2+270*s-64*sqrt30*s)*(-35*t+pt1)*tp1*tm1, (1.0/3057600)*pt1*(3*sqrt30-5)*(-2100-210*sqrt30+1120*sqrt30*s2-4725*s2+630*sqrt30*t2+54075*t2+1820*pt1*t3-79625*t4-1030*pt1*t-12*pt1*sqrt30*t-270*s2*pt1*t+64*sqrt30*s2*pt1*t+14175*s2*t2-3360*sqrt30*s2*t2)*sm1);
dpsi[20] = svector<2>((128.0/507)*tm1*tp1*(-4*t+sqrt3)*(s*sqrt3+2-6*s2), (128.0/507)*(2-6*t2+t*sqrt3)*sm1*sp1*(-4*s+sqrt3));
dpsi[21] = svector<2>((128.0/507)*tm1*tp1*(-4*t+sqrt3)*(s*sqrt3-2+6*s2), (128.0/507)*(2-6*t2+t*sqrt3)*sm1*sp1*(4*s+sqrt3));
dpsi[22] = svector<2>((128.0/507)*tm1*tp1*(4*t+sqrt3)*(s*sqrt3-2+6*s2), (128.0/507)*(t*sqrt3+6*t2-2)*sm1*sp1*(4*s+sqrt3));
dpsi[23] = svector<2>((128.0/507)*tm1*tp1*(4*t+sqrt3)*(s*sqrt3+2-6*s2), (128.0/507)*(t*sqrt3+6*t2-2)*sm1*sp1*(-4*s+sqrt3));
 
  return;
}

void quad24Permutation(const int *nodes, int *dof)
{
  int temp;

  // permute the edge and face dof

  if(nodes[0] > nodes[1]) 
    { 
      temp = dof[4]; dof[4] = dof[7]; dof[7] = temp;
      temp = dof[5]; dof[5] = dof[6]; dof[6] = temp;

      temp = dof[20]; dof[20] = dof[21]; dof[21] = temp;
      temp = dof[22]; dof[22] = dof[23]; dof[23] = temp;
    }
  if(nodes[1] > nodes[2])
    { 
      temp = dof[8]; dof[8] = dof[11]; dof[11] = temp;
      temp = dof[9]; dof[9] = dof[10]; dof[10] = temp;
    }
  if(nodes[2] > nodes[3])
    { 
      temp = dof[12]; dof[12] = dof[15]; dof[15] = temp;
      temp = dof[13]; dof[13] = dof[14]; dof[14] = temp;
    }
  if(nodes[3] > nodes[0])
    { 
      temp = dof[16]; dof[16] = dof[19]; dof[19] = temp;
      temp = dof[17]; dof[17] = dof[18]; dof[18] = temp;

      temp = dof[20]; dof[20] = dof[23]; dof[23] = temp;
      temp = dof[21]; dof[21] = dof[22]; dof[22] = temp;
    }

  return;
}

void tet4( const svector<3> xi, double phi[4] , svector<3> dphi[4])
{
  double xi3 = 1 - xi[0] - xi[1] - xi[2];
  
  phi[0] = xi3;  
  phi[1] = xi[0];
  phi[2] = xi[1];
  phi[3] = xi[2];
  
  if(dphi == NULL) return;
  
  dphi[0] = svector<3>(-1,-1,-1);
  dphi[1] = svector<3>( 1, 0, 0);
  dphi[2] = svector<3>( 0, 1, 0);
  dphi[3] = svector<3>( 0, 0, 1);
  
return;
}

void tet4Bubble(svector<3> xi, double phi[4] , svector<3> dphi[4])
{
  double xi3 = 1 - xi[0] - xi[1] - xi[2], bb = xi[0]*xi[1]*xi[2];
  
  phi[0] = xi3;  
  phi[1] = xi[0];
  phi[2] = xi[1];
  phi[3] = xi[2];
  
  phi[4] = bb * xi3;

  if(dphi == NULL) return;
  
  dphi[0] = svector<3>(-1,-1,-1);
  dphi[1] = svector<3>( 1, 0, 0);
  dphi[2] = svector<3>( 0, 1, 0);
  dphi[3] = svector<3>( 0, 0, 1);
  
  dphi[4][0] = xi[1]*xi[2]*xi3 - bb;
  dphi[4][1] = xi[2]*xi[0]*xi3 - bb;
  dphi[4][2] = xi[0]*xi[1]*xi3 - bb;

return;
}

void tet10(const svector<3> xi, double phi[10], svector<3> dphi[10])  
{
double eta[4];

eta[0] = 1 - xi[0] - xi[1] - xi[2];   // baracentric coordiates

 if(dphi != NULL)
   {
     dphi[0] = svector<3>(-1,-1,-1);
     dphi[1] = svector<3>( 1, 0, 0);
     dphi[2] = svector<3>( 0, 1, 0);
     dphi[3] = svector<3>( 0, 0, 1);
   }

for(int i = 0; i < 3; i++)   // mid sides (0,1) (1,2) (2,0)
  {
  eta[i+1] = xi[i];   // baracentric coordiates

  phi[4+i] = 4 * eta[i] * eta[(i+1)%3];

  if(dphi != NULL)
    dphi[4+i] = (4 * eta[(i+1)%3]) * dphi[i] + (4 * eta[i]) * dphi[(i+1)%3];
  }
 
for(int i = 0; i < 3; i++)   // mid sides (0,3) (1,3) (2,3)
  {
  phi[7+i] = 4 * eta[i] * eta[3];

  if(dphi != NULL)
    dphi[7+i] = (4 * eta[3]) * dphi[i] + (4 * eta[i]) * dphi[3];
  }

for(int i = 0; i < 4; i++)   // vetriex basis functions
  {
  phi[i] = 2 * eta[i] * (eta[i] - 0.5);

  if(dphi != NULL)
    dphi[i] = (4 * eta[i] - 1) * dphi[i];
  }

return;
}

void tet20Permutation(const int *nodes, int *dof)
{
  int temp;

  // permute the edge dof

  if(nodes[0] > nodes[1]) {temp = dof[ 4]; dof[ 4] = dof[ 5]; dof[ 5] = temp;}
  if(nodes[1] > nodes[2]) {temp = dof[ 6]; dof[ 6] = dof[ 7]; dof[ 7] = temp;}
  if(nodes[2] > nodes[0]) {temp = dof[ 8]; dof[ 8] = dof[ 9]; dof[ 9] = temp;}

  if(nodes[3] > nodes[0]) {temp = dof[10]; dof[10] = dof[11]; dof[11] = temp;}
  if(nodes[3] > nodes[1]) {temp = dof[12]; dof[12] = dof[13]; dof[13] = temp;}
  if(nodes[3] > nodes[2]) {temp = dof[14]; dof[14] = dof[15]; dof[15] = temp;}

  return;
}

void tet20(const svector<3> pt, double psi[20], svector<3> dpsi[20])  
{

  double xi = pt[0], eta = pt[1], chi=pt[2];
  double  eta2 = eta*eta, xi2 = xi*xi, chi2 = chi*chi;
  double sqrt5 = sqrt(5.0);

psi[0] = -(xi-1+eta+chi)*(5*xi2+11*chi*xi-5*xi+11*xi*eta-5*eta+1+5*chi2-5*chi+11*eta*chi+5*eta2);
psi[1] = (5*xi2-chi*xi-5*xi-xi*eta+1-eta*chi+eta+chi-eta2-chi2)*xi;
psi[2] = -(-5*eta2+5*eta+eta*chi+xi*eta-1-xi-chi+xi2+chi*xi+chi2)*eta;
psi[3] = -(-5*chi2+5*chi+chi*xi+eta*chi-1-eta-xi+eta2+xi*eta+xi2)*chi;
psi[4] = 0.5*sqrt5*xi*(xi-1+eta+chi)*(10*xi-sqrt5+3*chi*sqrt5-5+5*chi+5*eta+3*eta*sqrt5);
psi[5] = -0.5*sqrt5*xi*(xi-1+eta+chi)*(10*xi-5-3*chi*sqrt5+sqrt5+5*chi+5*eta-3*eta*sqrt5);
psi[6] = 1.25*(sqrt5+3)*(2*xi-3+7*eta-3*eta*sqrt5+sqrt5)*xi*eta;
psi[7] = -1.25*(sqrt5-3)*(2*xi-3+3*eta*sqrt5+7*eta-sqrt5)*xi*eta;
psi[8] = -1.25*(sqrt5-3)*eta*(xi-1+eta+chi)*(2*xi-3*eta*sqrt5+2*chi-5*eta+sqrt5+1);
psi[9] = 1.25*(sqrt5+3)*eta*(xi-1+eta+chi)*(2*xi+2*chi-5*eta-sqrt5+3*eta*sqrt5+1);
psi[10] = -1.25*(sqrt5-3)*chi*(2*xi+1+2*eta+sqrt5-5*chi-3*chi*sqrt5)*(xi-1+eta+chi);
psi[11] = 1.25*(sqrt5+3)*chi*(xi-1+eta+chi)*(2*xi+3*chi*sqrt5-5*chi+2*eta-sqrt5+1);
psi[12] = -1.25*(sqrt5-3)*(2*xi-3+3*chi*sqrt5+7*chi-sqrt5)*xi*chi;
psi[13] = 1.25*(sqrt5+3)*(2*xi-3+7*chi-3*chi*sqrt5+sqrt5)*xi*chi;
psi[14] = -1.25*(sqrt5-3)*(2*eta-3+3*chi*sqrt5+7*chi-sqrt5)*eta*chi;
psi[15] = 1.25*(sqrt5+3)*(2*eta-3+7*chi-3*chi*sqrt5+sqrt5)*eta*chi;
psi[16] = 27*xi*eta*chi;
psi[17] = -27*(xi-1+eta+chi)*eta*chi;
psi[18] = -27*(xi-1+eta+chi)*xi*chi;
psi[19] = -27*(xi-1+eta+chi)*xi*eta;

 if(dpsi == NULL) return;

dpsi[0] = svector<3>(-15*xi2-32*chi*xi+20*xi-32*xi*eta+21*eta-6-16*chi2+21*chi-33*eta*chi-16*eta2,-16*xi2-33*chi*xi+21*xi-32*xi*eta+20*eta-6-16*chi2+21*chi-32*eta*chi-15*eta2,-16*xi2-32*chi*xi+21*xi-33*xi*eta+21*eta-6-15*chi2+20*chi-32*eta*chi-16*eta2);
dpsi[1] = svector<3>(15*xi2-2*chi*xi-10*xi-2*xi*eta+1-eta*chi+eta+chi-eta2-chi2,-(xi+chi-1+2*eta)*xi,-(xi+eta-1+2*chi)*xi);
dpsi[2] = svector<3>(-(eta-1+2*xi+chi)*eta,15*eta2-10*eta-2*eta*chi-2*xi*eta+1+xi+chi-xi2-chi*xi-chi2,-(xi+eta-1+2*chi)*eta);
dpsi[3] = svector<3>(-(eta-1+2*xi+chi)*chi,-(xi+chi-1+2*eta)*chi,15*chi2-10*chi-2*chi*xi-2*eta*chi+1+eta+xi-eta2-xi*eta-xi2);
dpsi[4] = svector<3>(0.5*sqrt5*(6*xi*eta*sqrt5+6*eta*chi*sqrt5+6*xi*chi*sqrt5-2*xi*sqrt5-4*eta*sqrt5-4*chi*sqrt5+3*eta2*sqrt5+3*chi2*sqrt5+sqrt5+5*eta2+5*chi2+30*xi2+5-10*chi-10*eta-30*xi+30*chi*xi+10*eta*chi+30*xi*eta),1.25*(sqrt5+1)*xi*(-3+2*chi-sqrt5+2*chi*sqrt5+2*eta*sqrt5+2*eta+6*xi),1.25*(sqrt5+1)*xi*(-3+2*chi-sqrt5+2*chi*sqrt5+2*eta*sqrt5+2*eta+6*xi));
dpsi[5] = svector<3>(-0.5*sqrt5*(-6*xi*eta*sqrt5-6*eta*chi*sqrt5-6*xi*chi*sqrt5+2*xi*sqrt5+4*eta*sqrt5+4*chi*sqrt5-3*eta2*sqrt5-3*chi2*sqrt5-sqrt5+5*eta2+5*chi2+30*xi2+5-10*chi-10*eta-30*xi+30*chi*xi+10*eta*chi+30*xi*eta),-1.25*(sqrt5-1)*xi*(6*xi-3-2*chi*sqrt5+sqrt5+2*chi+2*eta-2*eta*sqrt5),-1.25*(sqrt5-1)*xi*(6*xi-3-2*chi*sqrt5+sqrt5+2*chi+2*eta-2*eta*sqrt5));
dpsi[6] = svector<3>(1.25*(sqrt5+3)*(7*eta-3*eta*sqrt5-3+4*xi+sqrt5)*eta,1.25*(sqrt5+3)*(2*xi+sqrt5-3+14*eta-6*eta*sqrt5)*xi,0);
dpsi[7] = svector<3>(-1.25*(sqrt5-3)*(7*eta+3*eta*sqrt5-sqrt5+4*xi-3)*eta,-1.25*(sqrt5-3)*(2*xi-sqrt5-3+6*eta*sqrt5+14*eta)*xi,0);
dpsi[8] = svector<3>(-1.25*(sqrt5-3)*eta*(4*xi+4*chi+sqrt5-1-3*eta-3*eta*sqrt5),-1.25*(sqrt5-3)*(-6*xi*eta-6*eta*chi+4*chi*xi-xi+12*eta-chi+2*xi2-15*eta2+2*chi2-9*eta2*sqrt5-sqrt5+chi*sqrt5+8*eta*sqrt5+xi*sqrt5-1-6*eta*chi*sqrt5-6*xi*eta*sqrt5),-1.25*(sqrt5-3)*eta*(4*xi+4*chi+sqrt5-1-3*eta-3*eta*sqrt5));
dpsi[9] = svector<3>(1.25*(sqrt5+3)*eta*(4*xi+4*chi-3*eta+3*eta*sqrt5-sqrt5-1),1.25*(sqrt5+3)*(-6*xi*eta-6*eta*chi+4*chi*xi-xi+12*eta-chi+2*xi2-15*eta2+2*chi2+9*eta2*sqrt5+sqrt5-chi*sqrt5-8*eta*sqrt5-xi*sqrt5-1+6*eta*chi*sqrt5+6*xi*eta*sqrt5),1.25*(sqrt5+3)*eta*(4*xi+4*chi-3*eta+3*eta*sqrt5-sqrt5-1));
dpsi[10] = svector<3>(-1.25*(sqrt5-3)*chi*(4*xi-1+sqrt5+4*eta-3*chi-3*chi*sqrt5),-1.25*(sqrt5-3)*chi*(4*xi-1+sqrt5+4*eta-3*chi-3*chi*sqrt5),-1.25*(sqrt5-3)*(4*xi*eta-6*eta*chi-6*chi*xi-xi-eta+12*chi+2*xi2+2*eta2-15*chi2-9*chi2*sqrt5-sqrt5+8*chi*sqrt5+eta*sqrt5+xi*sqrt5-1-6*xi*chi*sqrt5-6*eta*chi*sqrt5));
dpsi[11] = svector<3>(1.25*(sqrt5+3)*chi*(4*xi-3*chi+3*chi*sqrt5+4*eta-sqrt5-1),1.25*(sqrt5+3)*chi*(4*xi-3*chi+3*chi*sqrt5+4*eta-sqrt5-1),1.25*(sqrt5+3)*(4*xi*eta-6*eta*chi-6*chi*xi-xi-eta+12*chi+2*xi2+2*eta2-15*chi2+9*chi2*sqrt5+sqrt5-8*chi*sqrt5-eta*sqrt5-xi*sqrt5-1+6*xi*chi*sqrt5+6*eta*chi*sqrt5));
dpsi[12] = svector<3>(-1.25*(sqrt5-3)*(7*chi+3*chi*sqrt5-sqrt5+4*xi-3)*chi,0,-1.25*(sqrt5-3)*(2*xi-sqrt5-3+6*chi*sqrt5+14*chi)*xi);
dpsi[13] = svector<3>(1.25*(sqrt5+3)*(7*chi-3*chi*sqrt5-3+4*xi+sqrt5)*chi,0,1.25*(sqrt5+3)*(2*xi+sqrt5-3+14*chi-6*chi*sqrt5)*xi);
dpsi[14] = svector<3>(0,-1.25*(sqrt5-3)*(7*chi+3*chi*sqrt5-sqrt5+4*eta-3)*chi,-1.25*(sqrt5-3)*(2*eta-sqrt5-3+6*chi*sqrt5+14*chi)*eta);
dpsi[15] = svector<3>(0,1.25*(sqrt5+3)*(-3*chi*sqrt5+7*chi-3+4*eta+sqrt5)*chi,1.25*(sqrt5+3)*(2*eta+sqrt5-3+14*chi-6*chi*sqrt5)*eta);
dpsi[16] = svector<3>(27*eta*chi,27*chi*xi,27*xi*eta);
dpsi[17] = svector<3>(-27*eta*chi,-27*(xi+chi-1+2*eta)*chi,-27*(xi+eta-1+2*chi)*eta);
dpsi[18] = svector<3>(-27*(eta-1+2*xi+chi)*chi,-27*chi*xi,-27*(xi+eta-1+2*chi)*xi);
dpsi[19] = svector<3>(-27*(eta-1+2*xi+chi)*eta,-27*(xi+chi-1+2*eta)*xi,-27*xi*eta);

  return;
}


void cube8(svector<3> xi, double psi[8], svector<3> dpsi[8])
{
double eta = xi[0], ata = xi[1], chi = xi[2];

double ope = (1+eta)/2, opa = (1+ata)/2, opc = (1+chi)/2;
double ome = (1-eta)/2, oma = (1-ata)/2, omc = (1-chi)/2;

 psi[0] = ome * oma * omc;
 psi[1] = ope * oma * omc;
 psi[2] = ome * opa * omc;
 psi[3] = ope * opa * omc;
 psi[4] = ome * oma * opc;
 psi[5] = ope * oma * opc;
 psi[6] = ome * opa * opc;
 psi[7] = ope * opa * opc;

 if(dpsi == NULL) return;

 dpsi[0] = -0.5 * svector<3>( oma * omc,  ome * omc,  ome * oma);
 dpsi[1] =  0.5 * svector<3>( oma * omc, -ope * omc, -ope * oma);
 dpsi[2] =  0.5 * svector<3>(-opa * omc,  ome * omc, -ome * opa);
 dpsi[3] =  0.5 * svector<3>( opa * omc,  ope * omc, -ope * opa);
 dpsi[4] =  0.5 * svector<3>(-oma * opc, -ome * opc,  ome * oma);
 dpsi[5] =  0.5 * svector<3>( oma * opc, -ope * opc,  ope * oma);
 dpsi[6] =  0.5 * svector<3>(-opa * opc,  ome * opc,  ome * opa);
 dpsi[7] =  0.5 * svector<3>( opa * opc,  ope * opc,  ope * opa);

 return;
}

void cube8Bubble(svector<3> xi, double psi[9], svector<3> dpsi[9])
{
  double eta = xi[0], ata = xi[1], chi = xi[2];

  double ope = (1+eta)/2, opa = (1+ata)/2, opc = (1+chi)/2;
  double ome = (1-eta)/2, oma = (1-ata)/2, omc = (1-chi)/2;

  double bb = (1-eta*eta)*(1-ata*ata)*(1-chi*chi);
  double bw = 1 + (eta + ata + chi) + (eta*ata + ata*chi + chi*eta);

 psi[0] = ome * oma * omc;
 psi[1] = ope * oma * omc;
 psi[2] = ome * opa * omc;
 psi[3] = ope * opa * omc;
 psi[4] = ome * oma * opc;
 psi[5] = ope * oma * opc;
 psi[6] = ome * opa * opc;
 psi[7] = ope * opa * opc;

 psi[8] = bb*bw;

 if(dpsi == NULL) return;

 dpsi[0] = -0.5 * svector<3>( oma * omc,  ome * omc,  ome * oma);
 dpsi[1] =  0.5 * svector<3>( oma * omc, -ope * omc, -ope * oma);
 dpsi[2] =  0.5 * svector<3>(-opa * omc,  ome * omc, -ome * opa);
 dpsi[3] =  0.5 * svector<3>( opa * omc,  ope * omc, -ope * opa);
 dpsi[4] =  0.5 * svector<3>(-oma * opc, -ome * opc,  ome * oma);
 dpsi[5] =  0.5 * svector<3>( oma * opc, -ope * opc,  ope * oma);
 dpsi[6] =  0.5 * svector<3>(-opa * opc,  ome * opc,  ome * opa);
 dpsi[7] =  0.5 * svector<3>( opa * opc,  ope * opc,  ope * opa);

 dpsi[8][0] = bb*(1+ata+chi) - 2*eta*(1-ata*ata)*(1-chi*chi)*bw;
 dpsi[8][1] = bb*(1+chi+eta) - 2*ata*(1-chi*chi)*(1-eta*eta)*bw;
 dpsi[8][2] = bb*(1+eta+ata) - 2*chi*(1-eta*eta)*(1-ata*ata)*bw;

 return;
}

void cube20(svector<3> xi, double psi[20], svector<3> dpsi[20])
{
  double eta = xi[0], ata = xi[1], chi = xi[2];
  double ope = (1+eta)/2, opa = (1+ata)/2, opc = (1+chi)/2;
  double ome = (1-eta)/2, oma = (1-ata)/2, omc = (1-chi)/2;
  double ome2= 1-eta*eta, oma2= 1-ata*ata, omc2= 1-chi*chi;
  
  psi[0] = ome * oma * omc * ((-eta - ata - chi) - 2);
  psi[1] = ope * oma * omc * (( eta - ata - chi) - 2);
  psi[2] = ome * opa * omc * ((-eta + ata - chi) - 2);
  psi[3] = ope * opa * omc * (( eta + ata - chi) - 2);
  psi[4] = ome * oma * opc * ((-eta - ata + chi) - 2);
  psi[5] = ope * oma * opc * (( eta - ata + chi) - 2);
  psi[6] = ome * opa * opc * ((-eta + ata + chi) - 2);
  psi[7] = ope * opa * opc * (( eta + ata + chi) - 2);
  
  psi[8] = ome2 * oma * omc;
  psi[9] = ome2 * opa * omc;
  psi[10]= ome2 * oma * opc;
  psi[11]= ome2 * opa * opc;
  
  psi[12]= ome * oma2 * omc;
  psi[13]= ope * oma2 * omc;
  psi[14]= ome * oma2 * opc;
  psi[15]= ope * oma2 * opc;
  
  psi[16]= ome * oma * omc2;
  psi[17]= ope * oma * omc2;
  psi[18]= ome * opa * omc2;
  psi[19]= ope * opa * omc2;

  if(dpsi == NULL) return;
  
  dpsi[0] = svector<3>(oma * omc * ( chi + ata + 2*eta + 1)/ 2,
		       ome * omc * ( chi + 2*ata + eta + 1)/ 2, 
		       ome * oma * ( 2*chi + ata + eta + 1)/ 2);

  dpsi[1] = svector<3>(oma * omc * ( chi + ata - 2*eta + 1)/-2,
		       ope * omc * ( chi + 2*ata - eta + 1)/ 2, 
		       ope * oma * ( 2*chi + ata - eta + 1)/ 2);
  
  dpsi[2] = svector<3>(opa * omc * ( chi - ata + 2*eta + 1)/ 2, 
		       ome * omc * ( chi - 2*ata + eta + 1)/-2, 
		       ome * opa * ( 2*chi - ata + eta + 1)/ 2);
  
  dpsi[3] = svector<3>(opa * omc * ( chi - ata - 2*eta + 1)/-2, 
		       ope * omc * ( chi - 2*ata - eta + 1)/-2, 
		       ope * opa * ( 2*chi - ata - eta + 1)/ 2);
  
  dpsi[4] = svector<3>(oma * opc * (-chi + ata + 2*eta + 1)/ 2, 
		       ome * opc * (-chi + 2*ata + eta + 1)/ 2, 
		       ome * oma * (-2*chi + ata + eta + 1)/-2);
  
  dpsi[5] = svector<3>(oma * opc * (-chi + ata - 2*eta + 1)/-2, 
		       ope * opc * (-chi + 2*ata - eta + 1)/ 2, 
		       ope * oma * (-2*chi + ata - eta + 1)/-2);
  
  dpsi[6] = svector<3>(opa * opc * (-chi - ata + 2*eta + 1)/ 2, 
		       ome * opc * (-chi - 2*ata + eta + 1)/-2, 
		       ome * opa * (-2*chi - ata + eta + 1)/-2);
  
  dpsi[7] = svector<3>(opa * opc * (-chi - ata - 2*eta + 1)/-2, 
		       ope * opc * (-chi - 2*ata - eta + 1)/-2, 
		       ope * opa * (-2*chi - ata - eta + 1)/-2);
  
  dpsi[8] = svector<3>(-2*eta*oma*omc, ome2*omc/-2, ome2*oma/-2);
  dpsi[9] = svector<3>(-2*eta*opa*omc, ome2*omc/ 2, ome2*opa/-2);
  dpsi[10] = svector<3>(-2*eta*oma*opc, ome2*opc/-2, ome2*oma/ 2);
  dpsi[11] = svector<3>(-2*eta*opa*opc, ome2*opc/ 2, ome2*opa/ 2);
  
  dpsi[12] = svector<3>(oma2*omc/-2, ome*-2*ata*omc, ome*oma2/-2);
  dpsi[13] = svector<3>(oma2*omc/ 2, ope*-2*ata*omc, ope*oma2/-2);
  dpsi[14] = svector<3>(oma2*opc/-2, ome*-2*ata*opc, ome*oma2/ 2);
  dpsi[15] = svector<3>(oma2*opc/ 2, ope*-2*ata*opc, ope*oma2/ 2);
  
  dpsi[16] = svector<3>(oma*omc2/-2, ome*omc2/-2, ome*oma*-2*chi);
  dpsi[17] = svector<3>(oma*omc2/ 2, ope*omc2/-2, ope*oma*-2*chi);
  dpsi[18] = svector<3>(opa*omc2/-2, ome*omc2/ 2, ome*opa*-2*chi);
  dpsi[19] = svector<3>(opa*omc2/ 2, ope*omc2/ 2, ope*opa*-2*chi);
  
  return;
}

void cube27(svector<3> xi, double phi[27], svector<3> dphi[27])
{
int i,j,k, ii = 0;
double onedeta[3], donedeta[3];
double onedata[3], donedata[3];
double onedchi[3], donedchi[3];

svector<1> vdonedeta[3], vdonedata[3], vdonedchi[3];

double eta = xi[0], ata = xi[1], chi = xi[2];

line3(eta,onedeta,vdonedeta);
line3(ata,onedata,vdonedata);
line3(chi,onedchi,vdonedchi);

for(int i = 0; i < 3; i++)
  {
    donedeta[i] = vdonedeta[i][0];
    donedata[i] = vdonedata[i][0];
    donedchi[i] = vdonedchi[i][0];
  } 

/* Nodes */

for(k = 0; k < 2; k ++)
for(j = 0; j < 2; j ++)
for(i = 0; i < 2; i ++)
  {
  phi[ii] = onedeta[i] * onedata[j] * onedchi[k];

  if(dphi != NULL)
    dphi[ii] = svector<3>(donedeta[i] *  onedata[j] *  onedchi[k],
			  onedeta[i] * donedata[j] *  onedchi[k],
			  onedeta[i] *  onedata[j] * donedchi[k]);

  ii++;
  }

/* Mid Edges */

for(k = 0; k < 2; k ++)
for(j = 0; j < 2; j ++)
  {
  phi[ii] = onedeta[2] * onedata[j] * onedchi[k];

  if(dphi != NULL)
    dphi[ii] = svector<3>(donedeta[2] *  onedata[j] *  onedchi[k],
			  onedeta[2] * donedata[j] *  onedchi[k],
			  onedeta[2] *  onedata[j] * donedchi[k]);
  
  ii++;
  }

for(k = 0; k < 2; k ++)
for(i = 0; i < 2; i ++)
  {
  phi[ii] = onedeta[i] * onedata[2] * onedchi[k];

  if(dphi != NULL)
    dphi[ii] = svector<3>(donedeta[i] *  onedata[2] *  onedchi[k],
			  onedeta[i] * donedata[2] *  onedchi[k],
			  onedeta[i] *  onedata[2] * donedchi[k]);
  
  ii++;
  }

for(j = 0; j < 2; j ++)
for(i = 0; i < 2; i ++)
  {
  phi[ii] = onedeta[i] * onedata[j] * onedchi[2];

  if(dphi != NULL)
    dphi[ii] = svector<3>(donedeta[i] *  onedata[j] *  onedchi[2],
			  onedeta[i] * donedata[j] *  onedchi[2],
			  onedeta[i] *  onedata[j] * donedchi[2]);
  
  ii++;
  }

/* Mid Faces */

for(k = 0; k < 2; k ++)
  {
  phi[ii] = onedeta[2] * onedata[2] * onedchi[k];

  if(dphi != NULL)
    dphi[ii] = svector<3>(donedeta[2] *  onedata[2] *  onedchi[k],
			  onedeta[2] * donedata[2] *  onedchi[k],
			  onedeta[2] *  onedata[2] * donedchi[k]);
  
  ii++;
  }

for(j = 0; j < 2; j ++)
  {
  phi[ii] = onedeta[2] * onedata[j] * onedchi[2];

  if(dphi != NULL)
    dphi[ii] = svector<3>(donedeta[2] *  onedata[j] *  onedchi[2],
			  onedeta[2] * donedata[j] *  onedchi[2],
			  onedeta[2] *  onedata[j] * donedchi[2]);

  ii++;
  }

for(i = 0; i < 2; i ++)
  {
  phi[ii] = onedeta[i] * onedata[2] * onedchi[2];

  if(dphi != NULL)
    dphi[ii] = svector<3>(donedeta[i] *  onedata[2] *  onedchi[2],
			  onedeta[i] * donedata[2] *  onedchi[2],
			  onedeta[i] *  onedata[2] * donedchi[2]);
  
  ii++;
  }

/* Mid Cell */

  phi[ii] = onedeta[2] * onedata[2] * onedchi[2];

  if(dphi != NULL)
    dphi[ii] = svector<3>(donedeta[2] *  onedata[2] *  onedchi[2],
			  onedeta[2] * donedata[2] *  onedchi[2],
			  onedeta[2] *  onedata[2] * donedchi[2]);
  return;
}
